var searchIndex = {};
searchIndex["cpp_to_rust_build_tools"] = {"doc":"Implementation of `cpp_to_rust`'s build script. Default generated build script uses this crate as a build dependency and just calls `cpp_to_rust_build_tools::run()`. If a custom build script is used, it should use this crate's API to perform necessary build steps.","items":[[3,"Config","cpp_to_rust_build_tools","Configuration of the build script.",null,null],[5,"run_and_return","","Same as `run()`, but result of the operation is returned to the caller.",null,{"inputs":[],"output":{"name":"result"}}],[5,"run","","Runs the build script with default configuration. See `Config::run` for more information.",null,null],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Constructs default configuration state based on information in the generated `build_script_data.json` file located at the crate root. The caller may change `CppBuildPaths` and `CppBuildConfig` values stored in this object and call `config.run()` to apply them.",0,{"inputs":[],"output":{"name":"result"}}],[11,"original_cpp_lib_version","","Returns version of the native C++ library used for generating this crate. This is the value set with `Config::set_cpp_lib_version` during generation, or `None` if the version was not set.",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"cpp_build_config","","Returns current `CppBuildConfig` data.",0,{"inputs":[{"name":"self"}],"output":{"name":"cppbuildconfig"}}],[11,"cpp_build_config_mut","","Returns mutable `CppBuildConfig` data.",0,{"inputs":[{"name":"self"}],"output":{"name":"cppbuildconfig"}}],[11,"set_cpp_build_config","","Sets new `CppBuildConfig` data.",0,{"inputs":[{"name":"self"},{"name":"cppbuildconfig"}],"output":null}],[11,"cpp_build_paths","","Returns current `CppBuildPaths` data.",0,{"inputs":[{"name":"self"}],"output":{"name":"cppbuildpaths"}}],[11,"cpp_build_paths_mut","","Returns mutable `CppBuildPaths` data.",0,{"inputs":[{"name":"self"}],"output":{"name":"cppbuildpaths"}}],[11,"set_cpp_build_paths","","Sets new `CppBuildPaths` data.",0,{"inputs":[{"name":"self"},{"name":"cppbuildpaths"}],"output":null}],[11,"run_and_return","","Same as `run()`, but result of the operation is returned to the caller.",0,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"run","","Starts build script with current configuration. The build script performs the following operations:",0,null]],"paths":[[3,"Config"]]};
searchIndex["cpp_to_rust_common"] = {"doc":"Utility types and functions used by `cpp_to_rust_generator` and `cpp_to_rust_build_tools` crates.","items":[[3,"BuildScriptData","cpp_to_rust_common","This type contains data serialized by the generator and placed to the generated crate's directory. The build script reads and uses this value.",null,null],[12,"cpp_build_config","","Information required to build the C++ wrapper library",0,null],[12,"cpp_lib_version","","Name of the original C++ library passed to the generator",0,null],[12,"cpp_wrapper_lib_name","","Name of C++ wrapper library",0,null],[0,"log","","Logger implementation",null,null],[3,"LoggerSettings","cpp_to_rust_common::log","Specifies where the logging messages should be sent.",null,null],[12,"file_path","","Write messages to specified file path. If `None`, logging to file is disabled.",1,null],[12,"write_to_stderr","","Write messages to stderr.",1,null],[3,"Logger","","Logger object. One logger manages messages of all categories. It's possible to use multiple loggers independently. Use `default_logger()` to get global `Logger` instance. Note that the instance is mutex-guarded.",null,null],[3,"DEFAULT_LOGGER","","",null,null],[4,"LoggerCategory","","Logger category. Logger can be configured to save messages of each category to a separate file.",null,null],[13,"Status","","",2,null],[13,"Error","","",2,null],[13,"DebugGeneral","","",2,null],[13,"DebugMoveFiles","","",2,null],[13,"DebugTemplateInstantiation","","",2,null],[13,"DebugInheritance","","",2,null],[13,"DebugParserSkips","","",2,null],[13,"DebugParser","","",2,null],[13,"DebugFfiSkips","","",2,null],[13,"DebugSignals","","",2,null],[13,"DebugAllocationPlace","","",2,null],[13,"DebugRustSkips","","",2,null],[13,"DebugQtDoc","","",2,null],[13,"DebugQtDocDeclarations","","",2,null],[13,"DebugQtHeaderNames","","",2,null],[5,"default_logger","","Returns global instance of `Logger`.",null,{"inputs":[],"output":{"name":"mutexguard"}}],[5,"status","","Convenience method to log status messages to the default logger.",null,{"inputs":[{"name":"t"}],"output":null}],[5,"error","","Convenience method to log error messages to the default logger.",null,{"inputs":[{"name":"t"}],"output":null}],[5,"log","","Convenience method to log messages to the default logger and specified `category`.",null,{"inputs":[{"name":"loggercategory"},{"name":"t"}],"output":null}],[5,"llog","","Convenience method to lazy-log messages to the default logger and specified `category`. If messages of `category` are not ignored, calls the passed closure and uses its output value as a message in that category.",null,{"inputs":[{"name":"loggercategory"},{"name":"f"}],"output":null}],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"loggercategory"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",2,{"inputs":[{"name":"self"},{"name":"loggercategory"}],"output":{"name":"bool"}}],[11,"hash","","",2,null],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",1,{"inputs":[],"output":{"name":"loggersettings"}}],[11,"default","","",3,{"inputs":[],"output":{"name":"logger"}}],[11,"new","","Creates a new logger.",3,{"inputs":[],"output":{"name":"logger"}}],[11,"set_default_settings","","Set settings for all categories that don't have specific category settings.",3,{"inputs":[{"name":"self"},{"name":"loggersettings"}],"output":null}],[11,"set_category_settings","","Set settings for `category`.",3,{"inputs":[{"name":"self"},{"name":"loggercategory"},{"name":"loggersettings"}],"output":null}],[11,"set_all_category_settings","","Set all specific category settings. Old category settings are removed.",3,{"inputs":[{"name":"self"},{"name":"hashmap"}],"output":null}],[11,"is_on","","Returns false if messages of `category` are ignored. This function can be used to skip expensive construction of messages.",3,{"inputs":[{"name":"self"},{"name":"loggercategory"}],"output":{"name":"bool"}}],[11,"llog","","Lazy-log. If messages of `category` are not ignored, calls the passed closure and uses its output value as a message in that category.",3,{"inputs":[{"name":"self"},{"name":"loggercategory"},{"name":"f"}],"output":null}],[11,"log","","Log a message `text` to `category`.",3,{"inputs":[{"name":"self"},{"name":"loggercategory"},{"name":"t"}],"output":null}],[11,"deref","","",4,{"inputs":[{"name":"self"}],"output":{"name":"mutex"}}],[11,"initialize","","",4,{"inputs":[{"name":"self"}],"output":null}],[0,"errors","cpp_to_rust_common","Error handling types based on `error_chain` crate.",null,null],[3,"Error","cpp_to_rust_common::errors","",null,null],[12,"0","","",5,null],[12,"1","","",5,null],[4,"ErrorKind","","",null,null],[13,"Msg","","",6,null],[13,"IO","","",6,null],[13,"Regex","","",6,null],[13,"Unexpected","","",6,null],[5,"unexpected","","Constructs an unexpected error",null,{"inputs":[{"name":"s"}],"output":{"name":"errorkind"}}],[5,"fancy_unwrap","","Works like `unwrap()`, but in case of an error, outputs formatted stack trace and chained error messages to the `Error` logging channel.",null,{"inputs":[{"name":"result"}],"output":{"name":"t"}}],[6,"Result","","",null,null],[8,"ChainErr","","",null,null],[10,"chain_err","","",7,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"result"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"kind","","",5,{"inputs":[{"name":"self"}],"output":{"name":"errorkind"}}],[11,"into_kind","","",5,{"inputs":[{"name":"self"}],"output":{"name":"errorkind"}}],[11,"iter","","",5,{"inputs":[{"name":"self"}],"output":{"name":"errorchainiter"}}],[11,"backtrace","","",5,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"description","","",5,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",5,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",5,{"inputs":[{"name":"error"}],"output":{"name":"self"}}],[11,"from","","",5,{"inputs":[{"name":"error"}],"output":{"name":"self"}}],[11,"from","","",5,{"inputs":[{"name":"errorkind"}],"output":{"name":"self"}}],[11,"from","","",5,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"from","","",5,{"inputs":[{"name":"string"}],"output":{"name":"self"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",6,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"from","","",6,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"from","","",6,{"inputs":[{"name":"string"}],"output":{"name":"self"}}],[11,"is_unexpected","","Returns true if this error was not deemed possible during development.",5,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"discard_expected","","Panics if the error is unexpected. Does nothing otherwise.",5,{"inputs":[{"name":"self"}],"output":null}],[11,"display_report","","Outputs formatted stack trace and chained error messages to the `Error` logging channel.",5,{"inputs":[{"name":"self"}],"output":null}],[0,"file_utils","cpp_to_rust_common","Various utilities for working with files",null,null],[3,"FileWrapper","cpp_to_rust_common::file_utils","A wrapper over `std::fs::File` containing ths file's  path.",null,null],[3,"ReadDirWrapper","","A wrapper over `std::fs::DirEntry` iterator with better error reporting",null,null],[5,"move_files","","Move file or directory `src` to `dst` recursively, overwriting previous contents of `dst`. If corresponding old file has the same content as the new file, timestamps of the old file are preserved.",null,{"inputs":[{"name":"pathbuf"},{"name":"pathbuf"}],"output":{"name":"result"}}],[5,"copy_recursively","","Copy file or directory `src` to `dst` recursively",null,{"inputs":[{"name":"pathbuf"},{"name":"pathbuf"}],"output":{"name":"result"}}],[5,"open_file","","A wrapper over `std::fs::File::open` with better error reporting.",null,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[5,"file_to_string","","Returns content of the file `path` as a string.",null,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[5,"create_file","","A wrapper over `std::fs::File::create` with better error reporting.",null,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[5,"open_file_with_options","","A wrapper over `std::fs::OpenOptions::open` with better error reporting.",null,{"inputs":[{"name":"p"},{"name":"openoptions"}],"output":{"name":"result"}}],[5,"load_json","","Deserialize value from JSON file `path`.",null,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[5,"save_json","","Serialize `value` into JSON file `path`.",null,{"inputs":[{"name":"p"},{"name":"t"}],"output":{"name":"result"}}],[5,"load_bincode","","Deserialize value from binary file `path`.",null,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[5,"save_bincode","","Serialize `value` into binary file `path`.",null,{"inputs":[{"name":"p"},{"name":"t"}],"output":{"name":"result"}}],[5,"load_toml","","Load data from a TOML file",null,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[5,"save_toml","","Save `data` to a TOML file",null,{"inputs":[{"name":"p"},{"name":"table"}],"output":{"name":"result"}}],[5,"create_dir","","A wrapper over `std::fs::create_dir` with better error reporting",null,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[5,"create_dir_all","","A wrapper over `std::fs::create_dir_all` with better error reporting",null,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[5,"remove_dir","","A wrapper over `std::fs::remove_dir` with better error reporting",null,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[5,"remove_dir_all","","A wrapper over `std::fs::remove_dir_all` with better error reporting",null,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[5,"remove_file","","A wrapper over `std::fs::remove_file` with better error reporting",null,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[5,"rename_file","","A wrapper over `std::fs::rename` with better error reporting",null,{"inputs":[{"name":"p"},{"name":"p2"}],"output":{"name":"result"}}],[5,"copy_file","","A wrapper over `std::fs::copy` with better error reporting",null,{"inputs":[{"name":"p"},{"name":"p2"}],"output":{"name":"result"}}],[5,"read_dir","","A wrapper over `std::fs::read_dir` with better error reporting",null,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[5,"canonicalize","","Canonicalize `path`. Similar to `std::fs::canonicalize`, but `\\?` prefix is removed. Windows implementation of `std::fs::canonicalize` adds this prefix, but many tools don't process it correctly, including CMake and compilers.",null,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[5,"path_to_str","","A wrapper over `Path::to_str` with better error reporting",null,{"inputs":[{"name":"path"}],"output":{"name":"result"}}],[5,"os_str_to_str","","A wrapper over `OsStr::to_str` with better error reporting",null,{"inputs":[{"name":"osstr"}],"output":{"name":"result"}}],[5,"os_string_into_string","","A wrapper over `OsString::into_string` with better error reporting",null,{"inputs":[{"name":"osstring"}],"output":{"name":"result"}}],[5,"repo_crate_local_path","","Returns current absolute path of `relative_path`. `relative_path` is relative to the repository root.",null,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[8,"PathBufWithAdded","","Adds `with_added` function for paths.",null,null],[10,"with_added","","Appends `path` to `self` and returns it as new `PathBuf`, leaving `self` unchanged.",8,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"name":"pathbuf"}}],[11,"read_all","","Read content of the file to a string",9,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"write","","Write `text` to the file",9,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"result"}}],[11,"into_file","","Returns underlying `std::fs::File`",9,{"inputs":[{"name":"self"}],"output":{"name":"file"}}],[11,"next","","",10,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[0,"string_utils","cpp_to_rust_common","Various utilities for string operations.",null,null],[3,"WordIterator","cpp_to_rust_common::string_utils","Iterator over words in a camel-case or snake-case string.",null,null],[8,"JoinWithSeparator","","Join items of a collection with separator.",null,null],[16,"Output","","Result type of the operation",11,null],[10,"join","","Join items of `self` with `separator`.",11,null],[8,"CaseOperations","","Convert to string with different cases",null,null],[10,"to_class_case","","Convert to class-case string (\"WordWordWord\")",12,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[10,"to_snake_case","","Convert to snake-case string (\"word_word_word\")",12,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[10,"to_upper_case_words","","Convert to upper-case string (\"WORD_WORD_WORD\")",12,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"new","","Create iterator over `string`.",13,{"inputs":[{"name":"str"}],"output":{"name":"worditerator"}}],[11,"next","","",13,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[0,"utils","cpp_to_rust_common","Various utilities.",null,null],[5,"exe_suffix","cpp_to_rust_common::utils","Returns proper executable file suffix on current platform. Returns `\".exe\"` on Windows and `\"\"` on other platforms.",null,{"inputs":[],"output":{"name":"str"}}],[5,"add_to_multihash","","Creates and empty collection at `hash[key]` if there isn't one already. Adds `value` to `hash[key]` collection.",null,{"inputs":[{"name":"hashmap"},{"name":"k"},{"name":"t"}],"output":null}],[5,"run_command","","Runs a command and checks that it was successful",null,{"inputs":[{"name":"command"}],"output":{"name":"result"}}],[5,"get_command_output","","Runs a command and returns its stdout if it was successful",null,{"inputs":[{"name":"command"}],"output":{"name":"result"}}],[8,"MapIfOk","","Perform a map operation that can fail",null,null],[10,"map_if_ok","","Call closure `f` on each element of the collection and return `Vec` of values returned by the closure. If closure returns `Err` at some iteration, return that `Err` instead.",14,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"result"}}],[0,"cpp_build_config","cpp_to_rust_common","Types for configuring build script behavior.",null,null],[3,"CppBuildConfig","cpp_to_rust_common::cpp_build_config","Information required to build the C++ wrapper library on every supported platform. it contains list of linked libraries, frameworks, compiler types and selected type of C++ wrapper library (shared or static). Default value of this object is set before generation of the crate using `cpp_to_rust_generator::config::Config::set_cpp_build_config` or `cpp_build_config_mut` and intended to be cross-platform.",null,null],[3,"CppBuildConfigData","","Platform-specific information required to build the C++ wrapper library. This type contains one configuration item of `CppBuildConfig`.",null,null],[3,"CppBuildPaths","","Machine-specific information required to build the C++ wrapper library. This type holds configuration properties that cannot be determined at the time of crate generation because they are always platform-dependent.",null,null],[4,"CppLibraryType","","Type of a C++ library (shared or static).",null,null],[13,"Shared","","",15,null],[13,"Static","","",15,null],[11,"default","","",16,{"inputs":[],"output":{"name":"cppbuildconfig"}}],[11,"fmt","","",16,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",16,{"inputs":[{"name":"self"}],"output":{"name":"cppbuildconfig"}}],[11,"fmt","","",15,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",15,{"inputs":[{"name":"self"}],"output":{"name":"cpplibrarytype"}}],[11,"eq","","",15,{"inputs":[{"name":"self"},{"name":"cpplibrarytype"}],"output":{"name":"bool"}}],[11,"fmt","","",17,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",17,{"inputs":[{"name":"self"}],"output":{"name":"cppbuildconfigdata"}}],[11,"default","","",17,{"inputs":[],"output":{"name":"cppbuildconfigdata"}}],[11,"new","","Constructs an empty object.",17,{"inputs":[],"output":{"name":"cppbuildconfigdata"}}],[11,"add_linked_lib","","Adds a library for linking. Used as `-l` option to the linker.",17,{"inputs":[{"name":"self"},{"name":"p"}],"output":null}],[11,"add_linked_framework","","Adds a framework for linking (OS X specific). Used as `-f` option to the linker.",17,{"inputs":[{"name":"self"},{"name":"p"}],"output":null}],[11,"add_compiler_flag","","Adds a command line argument for the C++ compiler.",17,{"inputs":[{"name":"self"},{"name":"p"}],"output":null}],[11,"add_compiler_flags","","Adds multiple flags. See `CppBuildConfigData::add_cpp_compiler_flag`.",17,{"inputs":[{"name":"self"},{"name":"iter"}],"output":null}],[11,"set_library_type","","Sets library type. C++ wrapper is static by default. Shared library can be used to work around MSVC linker's limitations.",17,{"inputs":[{"name":"self"},{"name":"cpplibrarytype"}],"output":null}],[11,"linked_libs","","Returns names of linked libraries.",17,null],[11,"linked_frameworks","","Returns names of linked frameworks.",17,null],[11,"compiler_flags","","Returns C++ compiler flags.",17,null],[11,"library_type","","Returns type of C++ wrapper libary (shared or static).",17,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"new","","Create an empty configuration",16,{"inputs":[],"output":{"name":"cppbuildconfig"}}],[11,"add","","Add `data` with `condition`.",16,{"inputs":[{"name":"self"},{"name":"condition"},{"name":"cppbuildconfigdata"}],"output":null}],[11,"eval","","Select all conditions that are true on `target`, combine all corresponding configuration items and return the result.",16,{"inputs":[{"name":"self"},{"name":"target"}],"output":{"name":"result"}}],[11,"fmt","","",18,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",18,{"inputs":[],"output":{"name":"cppbuildpaths"}}],[11,"clone","","",18,{"inputs":[{"name":"self"}],"output":{"name":"cppbuildpaths"}}],[11,"new","","Constructs an empty configuration object.",18,{"inputs":[],"output":{"name":"cppbuildpaths"}}],[11,"add_lib_path","","Adds `path` to a lib directory. It's supplied to the linker via `-L` option or environment variables.",18,{"inputs":[{"name":"self"},{"name":"p"}],"output":null}],[11,"add_framework_path","","Adds `path` to a framework directory (OS X specific). It's supplied to the linker via `-F` option or environment variables.",18,{"inputs":[{"name":"self"},{"name":"p"}],"output":null}],[11,"add_include_path","","Adds `path` to an include directory. It's supplied to the C++ parser and the C++ compiler via `-I` option.",18,{"inputs":[{"name":"self"},{"name":"p"}],"output":null}],[11,"apply_env","","If `CPP_TO_RUST_LIB_PATHS`, `CPP_TO_RUST_FRAMEWORK_PATHS` or `CPP_TO_RUST_INCLUDE_PATHS` environment variables are present, their values override current values of the object.",18,{"inputs":[{"name":"self"}],"output":null}],[11,"lib_paths","","Returns paths added via `add_lib_path`.",18,null],[11,"framework_paths","","Returns paths added via `add_framework_path`.",18,null],[11,"include_paths","","Returns paths added via `add_include_path`.",18,null],[0,"cpp_lib_builder","cpp_to_rust_common","Implements building a CMake-based C++ library.",null,null],[3,"CMakeVar","cpp_to_rust_common::cpp_lib_builder","A CMake variable with a name and a value.",null,null],[12,"name","","",19,null],[12,"value","","",19,null],[3,"CppLibBuilder","","Implements building a CMake-based C++ library. Construct a value and call `run()` to execute building.",null,null],[12,"cmake_source_dir","","Path to the source directory containing CMake config file",20,null],[12,"build_dir","","Path to the build directory (may not exist before building)",20,null],[12,"install_dir","","Path to the install directory (may not exist before building)",20,null],[12,"num_jobs","","Number of threads used to build the library. If `None` is supplied, number of threads will be detected automatically.",20,null],[12,"build_type","","CMake build type (Debug or Release)",20,null],[12,"cmake_vars","","Additional variables passed to CMake",20,null],[4,"BuildType","","CMake build type (Debug or Release)",null,null],[13,"Debug","","",21,null],[13,"Release","","",21,null],[11,"fmt","","",19,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",19,{"inputs":[{"name":"self"}],"output":{"name":"cmakevar"}}],[11,"new","","Creates a new variable.",19,{"inputs":[{"name":"s1"},{"name":"s2"}],"output":{"name":"cmakevar"}}],[11,"new_list","","Creates a new variable containing a list of values.",19,{"inputs":[{"name":"s"},{"name":"l"}],"output":{"name":"result"}}],[11,"new_path_list","","Creates a new variable containing a list of paths.",19,{"inputs":[{"name":"s"},{"name":"l"}],"output":{"name":"result"}}],[11,"fmt","","",21,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",21,{"inputs":[{"name":"self"}],"output":{"name":"buildtype"}}],[11,"fmt","","",20,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",20,{"inputs":[{"name":"self"}],"output":{"name":"cpplibbuilder"}}],[11,"run","","Builds the library.",20,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[0,"target","cpp_to_rust_common","Types for expressing properties of different target platforms and platform-based conditions",null,null],[3,"Target","cpp_to_rust_common::target","Combined information about a target, as reported by configuration values of the Rust compiler.",null,null],[12,"arch","","CPU architecture",22,null],[12,"os","","Operating system",22,null],[12,"family","","Operating system family",22,null],[12,"env","","Further disambiguates the target platform with information about the ABI/libc,",22,null],[12,"pointer_width","","Pointer width in bits,",22,null],[12,"endian","","Endianness of the target CPU",22,null],[4,"Arch","","CPU architecture, as reported by `target_arch`.",null,null],[13,"X86","","",23,null],[13,"X86_64","","",23,null],[13,"Mips","","",23,null],[13,"PowerPC","","",23,null],[13,"PowerPC64","","",23,null],[13,"Arm","","",23,null],[13,"AArch64","","",23,null],[4,"OS","","Operating system, as reported by `target_os`.",null,null],[13,"Windows","","",24,null],[13,"MacOS","","",24,null],[13,"IOS","","",24,null],[13,"Linux","","",24,null],[13,"Android","","",24,null],[13,"FreeBSD","","",24,null],[13,"DragonFly","","",24,null],[13,"Bitrig","","",24,null],[13,"OpenBSD","","",24,null],[13,"NetBSD","","",24,null],[4,"Family","","Operating system family, as reported by `target_family`.",null,null],[13,"Windows","","",25,null],[13,"Unix","","",25,null],[4,"Env","","Further disambiguates the target platform with information about the ABI/libc, as reported by `target_env`.",null,null],[13,"Gnu","","",26,null],[13,"Msvc","","",26,null],[13,"Musl","","",26,null],[13,"None","","",26,null],[4,"PointerWidth","","Pointer width in bits, as reported by `target_pointer_width`.",null,null],[13,"P64","","",27,null],[13,"P32","","",27,null],[4,"Endian","","CPU endianness, as reported by `target_endian`.",null,null],[13,"Little","","",28,null],[13,"Big","","",28,null],[4,"Condition","","Condition on properties of the target. Simple conditions are considered true if the property of the current platform is the same as the associated value of the enum. For example, `Condition::OS(OS::Windows)` will be true on Windows and false otherwise. `And`, `Or` and `Not` variants provide logical operations on nested conditions. `True` and `False` variants provide conditions which are always true and false, respectively.",null,null],[13,"Arch","","",29,null],[13,"OS","","",29,null],[13,"Family","","",29,null],[13,"Env","","",29,null],[13,"PointerWidth","","",29,null],[13,"Endian","","",29,null],[13,"And","","",29,null],[13,"Or","","",29,null],[13,"Not","","",29,null],[13,"True","","",29,null],[13,"False","","",29,null],[5,"current_arch","","Returns current CPU architecture",null,{"inputs":[],"output":{"name":"arch"}}],[5,"current_os","","Returns current operating system",null,{"inputs":[],"output":{"name":"os"}}],[5,"current_family","","Returns current operating system family",null,{"inputs":[],"output":{"name":"family"}}],[5,"current_env","","Returns current platform disambiguation",null,{"inputs":[],"output":{"name":"env"}}],[5,"current_pointer_width","","Returns current pointer width",null,{"inputs":[],"output":{"name":"pointerwidth"}}],[5,"current_endian","","Returns current CPU endianness",null,{"inputs":[],"output":{"name":"endian"}}],[5,"current_target","","Returns properties of the current target",null,{"inputs":[],"output":{"name":"target"}}],[11,"fmt","","",23,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",23,{"inputs":[{"name":"self"}],"output":{"name":"arch"}}],[11,"eq","","",23,{"inputs":[{"name":"self"},{"name":"arch"}],"output":{"name":"bool"}}],[11,"fmt","","",24,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",24,{"inputs":[{"name":"self"}],"output":{"name":"os"}}],[11,"eq","","",24,{"inputs":[{"name":"self"},{"name":"os"}],"output":{"name":"bool"}}],[11,"fmt","","",25,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",25,{"inputs":[{"name":"self"}],"output":{"name":"family"}}],[11,"eq","","",25,{"inputs":[{"name":"self"},{"name":"family"}],"output":{"name":"bool"}}],[11,"fmt","","",26,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",26,{"inputs":[{"name":"self"}],"output":{"name":"env"}}],[11,"eq","","",26,{"inputs":[{"name":"self"},{"name":"env"}],"output":{"name":"bool"}}],[11,"fmt","","",27,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",27,{"inputs":[{"name":"self"}],"output":{"name":"pointerwidth"}}],[11,"eq","","",27,{"inputs":[{"name":"self"},{"name":"pointerwidth"}],"output":{"name":"bool"}}],[11,"fmt","","",28,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",28,{"inputs":[{"name":"self"}],"output":{"name":"endian"}}],[11,"eq","","",28,{"inputs":[{"name":"self"},{"name":"endian"}],"output":{"name":"bool"}}],[11,"fmt","","",22,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",22,{"inputs":[{"name":"self"}],"output":{"name":"target"}}],[11,"eq","","",22,{"inputs":[{"name":"self"},{"name":"target"}],"output":{"name":"bool"}}],[11,"ne","","",22,{"inputs":[{"name":"self"},{"name":"target"}],"output":{"name":"bool"}}],[11,"fmt","","",29,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",29,{"inputs":[{"name":"self"}],"output":{"name":"condition"}}],[11,"eq","","",29,{"inputs":[{"name":"self"},{"name":"condition"}],"output":{"name":"bool"}}],[11,"ne","","",29,{"inputs":[{"name":"self"},{"name":"condition"}],"output":{"name":"bool"}}],[11,"eval","","Evaluate the condition for `target`. Returns true if `target` matches the condition.",29,{"inputs":[{"name":"self"},{"name":"target"}],"output":{"name":"bool"}}],[11,"negate","","Construct a condition opposite to `self`.",29,{"inputs":[{"name":"self"}],"output":{"name":"condition"}}],[11,"fmt","cpp_to_rust_common","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"buildscriptdata"}}]],"paths":[[3,"BuildScriptData"],[3,"LoggerSettings"],[4,"LoggerCategory"],[3,"Logger"],[3,"DEFAULT_LOGGER"],[3,"Error"],[4,"ErrorKind"],[8,"ChainErr"],[8,"PathBufWithAdded"],[3,"FileWrapper"],[3,"ReadDirWrapper"],[8,"JoinWithSeparator"],[8,"CaseOperations"],[3,"WordIterator"],[8,"MapIfOk"],[4,"CppLibraryType"],[3,"CppBuildConfig"],[3,"CppBuildConfigData"],[3,"CppBuildPaths"],[3,"CMakeVar"],[3,"CppLibBuilder"],[4,"BuildType"],[3,"Target"],[4,"Arch"],[4,"OS"],[4,"Family"],[4,"Env"],[4,"PointerWidth"],[4,"Endian"],[4,"Condition"]]};
searchIndex["cpp_to_rust_generator"] = {"doc":"Implementation of `cpp_to_rust` generator that analyzes a C++ library and produces a Rust crate for it. See `README.md` for more information.","items":[[0,"config","cpp_to_rust_generator","Interface for configuring and running the generator.",null,null],[3,"CrateDependency","cpp_to_rust_generator::config","Information about an extra non-`cpp_to_rust`-based dependency.",null,null],[3,"CrateProperties","","Information about the crate being generated. Most of information in this object will be used in the output `Cargo.toml`.",null,null],[3,"Config","","The starting point of `cpp_to_rust` API. Create a `Config` object, set its properties, add custom functions if necessary, and start the processing with `Config::exec`.",null,null],[4,"CacheUsage","","Value of this enum determines how `cpp_to_rust` uses data from the cache directory accumulated in a previous processing of the same library.",null,null],[13,"Full","","The most aggressive caching. The generator will use all cached data and may even completely skip processing if it was completed before.",0,null],[13,"CppDataOnly","","The generator will use raw or processed C++ data if possible.",0,null],[13,"RawCppDataOnly","","The generator will use raw C++ data if possible.",0,null],[13,"None","","No cached data will be used.",0,null],[4,"DebugLoggingConfig","","Value of this enum determines how extra logging information will be used.",null,null],[13,"Print","","Output debug logs to stderr (noisy).",1,null],[13,"SaveToFile","","Save debug logs to `log` subdirectory of the cache directory.",1,null],[13,"Disable","","Disable debug logs.",1,null],[5,"is_completed","","Returns true if a library was already processed in this `cache_dir`. This function can be used to skip heavy preparation steps and avoid constructing a `Config` object. Note that the marker is not created if `write_cache` was set to false in `Config` during a previous run. The marker should only be used if cache usage is set to `CacheUsage::Full`.",null,{"inputs":[{"name":"p"}],"output":{"name":"bool"}}],[5,"completed_marker_path","","Returns path to the completion marker file indicating that processing of the library in this `cache_dir` was completed before. This function can be used to skip heavy preparation steps and avoid constructing a `Config` object. Note that the marker is not created if `write_cache` was set to false in `Config` during a previous run. The marker should only be used if cache usage is set to `CacheUsage::Full`.",null,{"inputs":[{"name":"p"}],"output":{"name":"pathbuf"}}],[6,"CppFfiGeneratorFilterFn","","Function type used in `Config::add_cpp_ffi_generator_filter`.",null,null],[6,"CppDataFilterFn","","Function type used in `Config::add_cpp_data_filter`.",null,null],[11,"default","","",2,{"inputs":[],"output":{"name":"cratedependency"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"cratedependency"}}],[11,"name","","Name of the crate (as in `Cargo.toml`)",2,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"version","","Version of the crate (as in `Cargo.toml`)",2,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"local_path","","Local path to the dependency (if present).",2,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"default","","",3,{"inputs":[],"output":{"name":"crateproperties"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"crateproperties"}}],[11,"new","","Creates a new object with `name` and `version`.",3,{"inputs":[{"name":"s1"},{"name":"s2"}],"output":{"name":"crateproperties"}}],[11,"add_author","","Adds an author for `authors` field of `Cargo.toml`.",3,{"inputs":[{"name":"self"},{"name":"s"}],"output":null}],[11,"set_links_attribute","","Sets value for `links` field of `Cargo.toml`. Native name of the C++ library should be used here.",3,{"inputs":[{"name":"self"},{"name":"s"}],"output":null}],[11,"add_dependency","","Adds an extra non-`cpp_to_rust`-based dependency with `name`, `version` and optionally `local_path`.",3,{"inputs":[{"name":"self"},{"name":"s1"},{"name":"s2"},{"name":"option"}],"output":null}],[11,"add_build_dependency","","Adds an extra build dependency with `name`, `version` and optionally `local_path`.",3,{"inputs":[{"name":"self"},{"name":"s1"},{"name":"s2"},{"name":"option"}],"output":null}],[11,"remove_default_dependencies","","Removes default dependencies from output `Cargo.toml`. Default dependencies are `libc`, `cpp_utils` and crates added using `Config::set_dependency_cache_paths`.",3,{"inputs":[{"name":"self"}],"output":null}],[11,"remove_default_build_dependencies","","Removes default build dependencies from output `Cargo.toml`. Default build dependency is `cpp_to_rust_build_tools`.",3,{"inputs":[{"name":"self"}],"output":null}],[11,"name","","Name of the crate",3,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"version","","Version of the crate",3,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"authors","","Authors of the crate",3,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"links_attribute","","`links` property of the crate",3,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"dependencies","","Extra non-`cpp_to_rust`-based dependencies of the crate",3,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"build_dependencies","","Extra build dependencies of the crate",3,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"should_remove_default_dependencies","","Returns true if default dependencies were removed.",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"should_remove_default_build_dependencies","","Returns true if default build dependencies were removed.",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"cacheusage"}],"output":{"name":"bool"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"cacheusage"}}],[11,"can_use_raw_cpp_data","","Returns true if raw C++ data file can be used in this mode.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"can_use_cpp_data","","Returns true if processed C++ data file can be used in this mode.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"can_skip_all","","Returns true if this mode allows to skip processing completely.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"default","","",0,{"inputs":[],"output":{"name":"cacheusage"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"debugloggingconfig"}],"output":{"name":"bool"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"debugloggingconfig"}}],[11,"default","","",1,{"inputs":[],"output":{"name":"debugloggingconfig"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a `Config`. `crate_properties` are used in Cargo.toml of the generated crate. `output_dir_path` will contain the generated crate. `cache_dir_path` will be used for cache, temporary files and inter-library information files.",4,{"inputs":[{"name":"p1"},{"name":"p2"},{"name":"crateproperties"}],"output":{"name":"config"}}],[11,"is_completed","","Returns true if a completion marker exists in the cache directory, indicating that processing of the library in this cache directory was completed before. Note that the marker is not created if `write_cache` was set to false. The marker will only be used if cache usage is set to `CacheUsage::Full`.",4,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"completed_marker_path","","Returns path to the completion marker file indicating that processing of the library in this cache directory was completed before. Note that the marker is not created if `write_cache` was set to false. The marker will only be used if cache usage is set to `CacheUsage::Full`.",4,{"inputs":[{"name":"self"}],"output":{"name":"pathbuf"}}],[11,"set_cache_usage","","Defines how cached data is used in repeated runs of the generator.",4,{"inputs":[{"name":"self"},{"name":"cacheusage"}],"output":null}],[11,"set_crate_template_path","","Sets the directory containing additional files for the crate. Any files and directories found in the crate template will be copied to the generated crate's directory, although some of them (such as `Cargo.toml`) may be overwritten with the generates files. It's common to put `tests` and `examples` subdirectories in the crate template so that `cargo` recognizes them automatically in the generated crate.",4,{"inputs":[{"name":"self"},{"name":"p"}],"output":null}],[11,"set_dependency_cache_paths","","Sets list of paths to cache directories of processed dependencies. The generator will integrate API of the current library with its dependencies and re-use their types.",4,{"inputs":[{"name":"self"},{"name":"vec"}],"output":null}],[11,"add_cpp_parser_blocked_name","","Adds a C++ identifier that should be skipped by the C++ parser. Identifier can contain namespaces and nested classes, with `::` separator (like in C++ identifiers). Identifier may refer to a method, a class, a enum or a namespace. All entities inside blacklisted entity (e.g. the methods of a blocked class or the contents of a blocked namespace) will also be skipped. All class methods with names matching the blocked name will be skipped, regardless of class name.",4,{"inputs":[{"name":"self"},{"name":"p"}],"output":null}],[11,"add_cpp_parser_blocked_names","","Adds multiple blocked names. See `Config::add_cpp_parser_blocked_name`.",4,{"inputs":[{"name":"self"},{"name":"iter"}],"output":null}],[11,"add_cpp_parser_argument","","Adds a command line argument for clang C++ parser.",4,{"inputs":[{"name":"self"},{"name":"p"}],"output":null}],[11,"add_cpp_parser_arguments","","Adds multiple command line arguments for clang C++ parser. See `Config::add_cpp_parser_argument`.",4,{"inputs":[{"name":"self"},{"name":"iter"}],"output":null}],[11,"add_include_path","","Adds path to an include directory. It's supplied to the C++ parser via `-I` option.",4,{"inputs":[{"name":"self"},{"name":"p"}],"output":null}],[11,"add_framework_path","","Adds path to a framework directory (OS X specific). It's supplied to the C++ parser via `-F` option.",4,{"inputs":[{"name":"self"},{"name":"p"}],"output":null}],[11,"add_target_include_path","","Adds path to an include directory or an include file of the target library. Any C++ types and methods will be parsed and used only if they are declared within one of files or directories added with this method.",4,{"inputs":[{"name":"self"},{"name":"p"}],"output":null}],[11,"add_include_directive","","Adds an include directive. Each directive will be added as `#include <path>` to the input file for the C++ parser. File name only paths or relative paths should be used in this method.",4,{"inputs":[{"name":"self"},{"name":"p"}],"output":null}],[11,"add_cpp_ffi_generator_filter","","Adds a custom function that decides whether a C++ method should be added to the C++ wrapper library. For each C++ method, each function will be run once. Filters are executed in the same order they were added.",4,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[11,"add_cpp_data_filter","","Adds a custom function that visits `&mut CppData` and can perform any changes in the output of the C++ parser. Filters are executed in the same order they were added. If the function returns `Err`, the processing is terminated.",4,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[11,"set_type_allocation_place","","Overrides automatic selection of type allocation place for `type_name` and uses `place` instead. See `CppTypeAllocationPlace` for more information.",4,{"inputs":[{"name":"self"},{"name":"cpptypeallocationplace"},{"name":"s"}],"output":null}],[11,"set_types_allocation_place","","Overrides automatic selection of type allocation place for `types` and uses `place` instead. See also `Config::set_type_allocation_place`.",4,{"inputs":[{"name":"self"},{"name":"cpptypeallocationplace"},{"name":"si"}],"output":null}],[11,"set_debug_logging_config","","Changes how debug logs are handled. See `DebugLoggingConfig` for more information.",4,{"inputs":[{"name":"self"},{"name":"debugloggingconfig"}],"output":null}],[11,"set_quiet_mode","","Sets quiet mode. In quiet mode status messages and debug logs are redirected to `log` subdirectory of the cache directory. Only error messages are always written to stderr. Quiet mode is disabled by default.",4,{"inputs":[{"name":"self"},{"name":"bool"}],"output":null}],[11,"set_write_cache","","Sets writing to cache mode. If enabled, result of processing is saved to extra files in cache directory. The main use of these files are loading dependency data. They are also used for speeding up repeated runs of the generator on the same library.",4,{"inputs":[{"name":"self"},{"name":"bool"}],"output":null}],[11,"set_cpp_build_config","","Sets `CppBuildConfig` value that will be passed to the build script of the generated crate.",4,{"inputs":[{"name":"self"},{"name":"cppbuildconfig"}],"output":null}],[11,"cpp_build_config_mut","","Allows to change `CppBuildConfig` value that will be passed to the build script of the generated crate.",4,{"inputs":[{"name":"self"}],"output":{"name":"cppbuildconfig"}}],[11,"set_cpp_lib_version","","",4,{"inputs":[{"name":"self"},{"name":"s"}],"output":null}],[11,"cpp_lib_version","","",4,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"exec","","Starts execution of the generator. This function will print the necessary build script output to stdout. It also displays some debugging output that can be made visible by running cargo commands with `-vv` option.",4,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"cache_usage","","Returns value set by `Config::set_cache_usage`.",4,{"inputs":[{"name":"self"}],"output":{"name":"cacheusage"}}],[11,"crate_properties","","Returns crate properties passed to `Config::new`.",4,{"inputs":[{"name":"self"}],"output":{"name":"crateproperties"}}],[11,"output_dir_path","","Returns path to the output directory passed to `Config::new`.",4,{"inputs":[{"name":"self"}],"output":{"name":"pathbuf"}}],[11,"cache_dir_path","","Returns path to the cache directory passed to `Config::new`.",4,{"inputs":[{"name":"self"}],"output":{"name":"pathbuf"}}],[11,"crate_template_path","","Returns value set by `Config::set_crate_template_path`.",4,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"dependency_cache_paths","","Returns value set by `Config::set_dependency_cache_paths`.",4,null],[11,"cpp_parser_blocked_names","","Returns names added with `Config::add_cpp_parser_blocked_name` and similar methods.",4,null],[11,"cpp_parser_arguments","","Returns names added with `Config::add_cpp_parser_argument` and similar methods.",4,null],[11,"include_paths","","Returns values added by `Config::add_include_path`.",4,null],[11,"framework_paths","","Returns values added by `Config::add_framework_path`.",4,null],[11,"target_include_paths","","Returns values added by `Config::add_target_include_path`.",4,null],[11,"include_directives","","Returns values added by `Config::add_include_directive`.",4,null],[11,"cpp_ffi_generator_filters","","Returns values added by `Config::add_cpp_ffi_generator_filter`.",4,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"cpp_data_filters","","Returns values added by `Config::add_cpp_data_filter`.",4,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"cpp_build_config","","Returns current `CppBuildConfig` value.",4,{"inputs":[{"name":"self"}],"output":{"name":"cppbuildconfig"}}],[11,"type_allocation_places","","Returns values added by `Config::set_type_allocation_place`. Keys of the hash map are names of C++ types.",4,{"inputs":[{"name":"self"}],"output":{"name":"hashmap"}}],[11,"set_write_dependencies_local_paths","","If `value` is `true`, the generated `Cargo.toml` will specify both versions and local paths of all dependencies. If `value` is `false`, only version will be specified, so publishing all dependencies would be required to build the crate.",4,{"inputs":[{"name":"self"},{"name":"bool"}],"output":null}],[11,"write_dependencies_local_paths","","Returns value set by `Config::set_write_dependencies_local_paths`.",4,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"debug_logging_config","","Returns value set by `Config::set_debug_logging_config`.",4,{"inputs":[{"name":"self"}],"output":{"name":"debugloggingconfig"}}],[11,"quiet_mode","","Returns value set by `Config::set_quiet_mode`.",4,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"write_cache","","Returns value set by `Config::set_write_cache`.",4,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[0,"cpp_data","cpp_to_rust_generator","Types for handling information about C++ library APIs.",null,null],[3,"CppEnumValue","cpp_to_rust_generator::cpp_data","One item of a C++ enum declaration",null,null],[12,"name","","Identifier",5,null],[12,"value","","Corresponding value",5,null],[12,"doc","","C++ documentation for this item in HTML",5,null],[3,"CppClassField","","Member field of a C++ class declaration",null,null],[12,"name","","Identifier",6,null],[12,"field_type","","Field type",6,null],[12,"visibility","","Visibility",6,null],[12,"size","","Size of type in bytes",6,null],[3,"CppClassUsingDirective","","A \"using\" directive inside a class definition, indicating that the class should inherite a certain method of a base class.",null,null],[12,"class_name","","Name of the base class",7,null],[12,"method_name","","Name of the method",7,null],[3,"CppBaseSpecifier","","Item of base class list in a class declaration",null,null],[12,"base_type","","Base class type (can include template arguments)",8,null],[12,"is_virtual","","True if this base is virtual",8,null],[12,"visibility","","Base visibility (public, protected or private)",8,null],[3,"CppOriginLocation","","Location of a C++ type's definition in header files.",null,null],[12,"include_file_path","","",9,null],[12,"line","","Line of the file",9,null],[12,"column","","Column of the file",9,null],[3,"CppTypeDoc","","C++ documentation for a type",null,null],[12,"html","","HTML content",10,null],[12,"url","","Absolute URL to online documentation page for this type",10,null],[12,"cross_references","","Absolute documentation URLs encountered in the content",10,null],[3,"CppTypeData","","Information about a C++ type declaration",null,null],[12,"name","","Identifier, including namespaces and nested classes (separated with \"::\", like in C++)",11,null],[12,"include_file","","File name of the include file (without full path)",11,null],[12,"origin_location","","Exact location of the declaration",11,null],[12,"kind","","Type information",11,null],[12,"doc","","C++ documentation data for this type",11,null],[3,"TemplateArgumentsDeclaration","","Information about template arguments of a C++ class type",null,null],[12,"nested_level","","Indicates how many template types this type is nested into.",12,null],[12,"names","","Names of template arguments. Names themselves are not particularly important, but their count is.",12,null],[3,"CppTemplateInstantiation","","Information about a C++ template class instantiation.",null,null],[12,"template_arguments","","List of template arguments used in this instantiation",13,null],[3,"CppTemplateInstantiations","","List of template instantiations of a template class.",null,null],[12,"class_name","","Template class name",14,null],[12,"instantiations","","List of encountered instantiations",14,null],[3,"CppData","","C++ parser output",null,null],[12,"types","","List of found type declarations",15,null],[12,"methods","","List of found methods",15,null],[12,"template_instantiations","","List of found template instantiations. Key is name of the template class, value is list of instantiations.",15,null],[12,"signal_argument_types","","List of all argument types used by signals, including variations with omitted arguments, but excluding argument types from dependencies.",15,null],[12,"type_allocation_places","","List of selected (automatically or in configuration) type allocation places for all class types.",15,null],[12,"dependencies","","Data of dependencies",15,null],[4,"CppTypeKind","","Information about a C++ type declaration",null,null],[13,"Enum","","Enum declaration",16,null],[12,"values","cpp_to_rust_generator::cpp_data::CppTypeKind","List of items",16,null],[13,"Class","cpp_to_rust_generator::cpp_data","Class declaration",16,null],[12,"bases","cpp_to_rust_generator::cpp_data::CppTypeKind","List of class types this class is derived from",16,null],[12,"fields","","List of class fields",16,null],[12,"template_arguments","","Information about template arguments of this type.",16,null],[12,"using_directives","","List of using directives, like \"using BaseClass::method1;\"",16,null],[4,"CppVisibility","cpp_to_rust_generator::cpp_data","Visibility of a C++ entity. Defaults to `Public` for entities that can't have visibility (like free functions)",null,null],[13,"Public","","",17,null],[13,"Protected","","",17,null],[13,"Private","","",17,null],[4,"CppTypeAllocationPlace","","Type allocation place of a C++ type.",null,null],[13,"Heap","","Values are stored on C++ heap and used as `CppBox<T>`.",18,null],[13,"Stack","","Values are stored on Rust stack and used as `T`.",18,null],[5,"create_cast_method","","Convenience function to create `CppMethod` object for `static_cast` or `dynamic_cast` from type `from` to type `to`. See `CppMethod`'s documentation for more information about `is_unsafe_static_cast` and `is_direct_static_cast`.",null,{"inputs":[{"name":"str"},{"name":"cpptype"},{"name":"cpptype"},{"name":"bool"},{"name":"bool"},{"name":"str"}],"output":{"name":"cppmethod"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"cppenumvalue"}],"output":{"name":"bool"}}],[11,"ne","","",5,{"inputs":[{"name":"self"},{"name":"cppenumvalue"}],"output":{"name":"bool"}}],[11,"clone","","",5,{"inputs":[{"name":"self"}],"output":{"name":"cppenumvalue"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",6,{"inputs":[{"name":"self"},{"name":"cppclassfield"}],"output":{"name":"bool"}}],[11,"ne","","",6,{"inputs":[{"name":"self"},{"name":"cppclassfield"}],"output":{"name":"bool"}}],[11,"clone","","",6,{"inputs":[{"name":"self"}],"output":{"name":"cppclassfield"}}],[11,"hash","","",6,null],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",7,{"inputs":[{"name":"self"},{"name":"cppclassusingdirective"}],"output":{"name":"bool"}}],[11,"ne","","",7,{"inputs":[{"name":"self"},{"name":"cppclassusingdirective"}],"output":{"name":"bool"}}],[11,"clone","","",7,{"inputs":[{"name":"self"}],"output":{"name":"cppclassusingdirective"}}],[11,"hash","","",7,null],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",8,{"inputs":[{"name":"self"},{"name":"cppbasespecifier"}],"output":{"name":"bool"}}],[11,"ne","","",8,{"inputs":[{"name":"self"},{"name":"cppbasespecifier"}],"output":{"name":"bool"}}],[11,"clone","","",8,{"inputs":[{"name":"self"}],"output":{"name":"cppbasespecifier"}}],[11,"hash","","",8,null],[11,"fmt","","",16,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",16,{"inputs":[{"name":"self"},{"name":"cpptypekind"}],"output":{"name":"bool"}}],[11,"ne","","",16,{"inputs":[{"name":"self"},{"name":"cpptypekind"}],"output":{"name":"bool"}}],[11,"clone","","",16,{"inputs":[{"name":"self"}],"output":{"name":"cpptypekind"}}],[11,"fmt","","",9,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",9,{"inputs":[{"name":"self"},{"name":"cpporiginlocation"}],"output":{"name":"bool"}}],[11,"ne","","",9,{"inputs":[{"name":"self"},{"name":"cpporiginlocation"}],"output":{"name":"bool"}}],[11,"clone","","",9,{"inputs":[{"name":"self"}],"output":{"name":"cpporiginlocation"}}],[11,"hash","","",9,null],[11,"fmt","","",17,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",17,{"inputs":[{"name":"self"},{"name":"cppvisibility"}],"output":{"name":"bool"}}],[11,"clone","","",17,{"inputs":[{"name":"self"}],"output":{"name":"cppvisibility"}}],[11,"hash","","",17,null],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",10,{"inputs":[{"name":"self"},{"name":"cpptypedoc"}],"output":{"name":"bool"}}],[11,"ne","","",10,{"inputs":[{"name":"self"},{"name":"cpptypedoc"}],"output":{"name":"bool"}}],[11,"clone","","",10,{"inputs":[{"name":"self"}],"output":{"name":"cpptypedoc"}}],[11,"fmt","","",11,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",11,{"inputs":[{"name":"self"},{"name":"cpptypedata"}],"output":{"name":"bool"}}],[11,"ne","","",11,{"inputs":[{"name":"self"},{"name":"cpptypedata"}],"output":{"name":"bool"}}],[11,"clone","","",11,{"inputs":[{"name":"self"}],"output":{"name":"cpptypedata"}}],[11,"fmt","","",12,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",12,{"inputs":[{"name":"self"},{"name":"templateargumentsdeclaration"}],"output":{"name":"bool"}}],[11,"ne","","",12,{"inputs":[{"name":"self"},{"name":"templateargumentsdeclaration"}],"output":{"name":"bool"}}],[11,"clone","","",12,{"inputs":[{"name":"self"}],"output":{"name":"templateargumentsdeclaration"}}],[11,"hash","","",12,null],[11,"fmt","","",13,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",13,{"inputs":[{"name":"self"},{"name":"cpptemplateinstantiation"}],"output":{"name":"bool"}}],[11,"ne","","",13,{"inputs":[{"name":"self"},{"name":"cpptemplateinstantiation"}],"output":{"name":"bool"}}],[11,"clone","","",13,{"inputs":[{"name":"self"}],"output":{"name":"cpptemplateinstantiation"}}],[11,"default","","",13,{"inputs":[],"output":{"name":"cpptemplateinstantiation"}}],[11,"fmt","","",14,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",14,{"inputs":[{"name":"self"},{"name":"cpptemplateinstantiations"}],"output":{"name":"bool"}}],[11,"ne","","",14,{"inputs":[{"name":"self"},{"name":"cpptemplateinstantiations"}],"output":{"name":"bool"}}],[11,"clone","","",14,{"inputs":[{"name":"self"}],"output":{"name":"cpptemplateinstantiations"}}],[11,"default","","",14,{"inputs":[],"output":{"name":"cpptemplateinstantiations"}}],[11,"fmt","","",18,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",18,{"inputs":[{"name":"self"},{"name":"cpptypeallocationplace"}],"output":{"name":"bool"}}],[11,"clone","","",18,{"inputs":[{"name":"self"}],"output":{"name":"cpptypeallocationplace"}}],[11,"fmt","","",15,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",15,{"inputs":[{"name":"self"},{"name":"cppdata"}],"output":{"name":"bool"}}],[11,"ne","","",15,{"inputs":[{"name":"self"},{"name":"cppdata"}],"output":{"name":"bool"}}],[11,"clone","","",15,{"inputs":[{"name":"self"}],"output":{"name":"cppdata"}}],[11,"default","","",15,{"inputs":[],"output":{"name":"cppdata"}}],[11,"is_class","","Checks if the type is a class type.",11,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"default_class_type","","Creates CppTypeBase object representing type of an object of this type. See default_template_arguments() documentation for details about handling template parameters.",11,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"default_template_arguments","","Creates template parameters expected for this type. For example, QHash<QString, int> will have 2 default template parameters with indexes 0 and 1. This function is helpful for determining type of \"this\" pointer. Result of this function may differ from actual template parameters, for example: - if a class is inside another template class, nested level should be 1 instead of 0; - if QList<V> type is used inside QHash<K, V> type, QList's template parameter will have index = 1 instead of 0.",11,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"inherits_directly","","Checks if the type was directly derived from specified type.",11,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[11,"find_type_info","","Search for a `CppTypeData` object in this `CppData` and all dependencies.",15,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"option"}}],[11,"is_polymorphic_type","","Returns true if C++ type `name` is polymorphic, i.e. has at least one virtual function.",15,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[11,"ensure_explicit_destructors","","Adds destructors for every class that does not have explicitly defined destructor, allowing to create wrappings for destructors implicitly available in C++.",15,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"add_inherited_methods","","Adds methods of derived classes inherited from base classes. A method will not be added if there is a method with the same name in the derived class. Constructors, destructors and assignment operators are also not added. This reflects C++'s method inheritance rules.",15,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"generate_methods_with_omitted_args","","Generates duplicate methods with fewer arguments for C++ methods with default argument values.",15,{"inputs":[{"name":"self"}],"output":null}],[11,"all_include_files","","Returns all include files found within this `CppData` (excluding dependencies).",15,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"is_template_class","","Checks if specified class is a template class.",15,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[11,"has_virtual_destructor","","Checks if specified class has virtual destructor (own or inherited).",15,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[11,"has_virtual_methods","","Checks if specified class has any virtual methods (own or inherited).",15,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[11,"has_public_destructor","","Checks if specified class has public destructor.",15,{"inputs":[{"name":"self"},{"name":"cpptypeclassbase"}],"output":{"name":"bool"}}],[11,"has_pure_virtual_methods","","Checks if specified class has any pure virtual methods.",15,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[11,"add_field_accessors","","Adds fictional getter and setter methods for each known public field of each class.",15,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"inherits","","Checks if `class_name` types inherits `base_name` type directly or indirectly.",15,{"inputs":[{"name":"self"},{"name":"str"},{"name":"str"}],"output":{"name":"bool"}}],[11,"choose_allocation_places","","Detects the preferred type allocation place for each type based on API of all known methods. Keys of `overrides` are C++ type names. If `overrides` contains type allocation place for a type, it's used instead of the place that would be automatically selected.",15,{"inputs":[{"name":"self"},{"name":"hashmap"}],"output":{"name":"result"}}],[11,"type_allocation_place","","Returns selected type allocation place for type `class_name`.",15,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[11,"post_process","","Performs data conversion to make it more suitable for further wrapper generation.",15,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"count","","Returns count of the template arguments.",12,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[0,"cpp_method","cpp_to_rust_generator","Types for handling information about C++ methods.",null,null],[3,"CppOperatorInfo","cpp_to_rust_generator::cpp_method","Constraints applied to a C++ operator method of a certain kind",null,null],[12,"function_name_suffix","","String that must appear after `\"operator\"` in the method name, e.g. `\">\"` for `\"operator>\"`. `\"operator\"` prefix must be present for any operator. This field is `None` for conversion operator, as its name includes corresponding C++ type instead of a fixed string.",19,null],[12,"arguments_count","","Total number of arguments, including implicit \"this\" argument. Most operators can be class members or free functions, but total number of arguments is the same in both cases.",19,null],[12,"allows_variadic_arguments","","True if this kind of operator can have variadic arguments. Only the function call operator has this property.",19,null],[3,"CppFunctionArgument","","Information about an argument of a C++ method",null,null],[12,"name","","Identifier. If the argument doesn't have a name (which is allowed in C++), this field contains generated name \"argX\" (X is position of the argument).",20,null],[12,"argument_type","","Argument type",20,null],[12,"has_default_value","","Flag indicating that the argument has default value and therefore can be omitted when calling the method",20,null],[3,"CppFieldAccessor","","for accessing a public field of a class",null,null],[12,"accessor_type","","Type of the accessor",21,null],[12,"field_name","","Name of the C++ field",21,null],[3,"CppMethodClassMembership","","Information about a C++ class member method",null,null],[12,"class_type","","Type of the class where this method belong. This is used to construct type of \"this\" pointer and return type of constructors.",22,null],[12,"kind","","Whether this method is a constructor, a destructor or an operator",22,null],[12,"is_virtual","","True if this is a virtual method",22,null],[12,"is_pure_virtual","","True if this is a pure virtual method (requires is_virtual = true)",22,null],[12,"is_const","","True if this is a const method, i.e. \"this\" pointer receives by this method has const type",22,null],[12,"is_static","","True if this is a static method, i.e. it doesn't receive \"this\" pointer at all.",22,null],[12,"visibility","","Method visibility",22,null],[12,"is_signal","","True if the method is a Qt signal",22,null],[12,"is_slot","","True if the method is a Qt slot",22,null],[12,"fake","","If this method is a generated field accessor, this field contains information about it. Field accessors do not have real C++ methods corresponding to them.",22,null],[3,"CppMethodDoc","","C++ documentation for a method",null,null],[12,"anchor","","HTML anchor of this documentation entry (used to detect duplicates)",23,null],[12,"html","","HTML content",23,null],[12,"mismatched_declaration","","If the documentation parser couldn't find documentation for the exact same method, it can still provide documentation entry for the closest match. In this case, this field should contain C++ declaration of the found method.",23,null],[12,"url","","Absolute URL to online documentation page for this method",23,null],[12,"cross_references","","Absolute documentation URLs encountered in the content",23,null],[3,"CppMethod","","Information about a C++ method",null,null],[12,"name","","Identifier. For class methods, this field includes only the method's own name. For free functions, this field also includes namespaces (if any).",24,null],[12,"class_membership","","Additional information about a class member function or None for free functions",24,null],[12,"operator","","If the method is a C++ operator, indicates its kind",24,null],[12,"return_type","","Return type of the method. Return type is reported as void for constructors and destructors.",24,null],[12,"arguments","","List of the method's arguments",24,null],[12,"arguments_before_omitting","","If Some, the method is derived from another method by omitting arguments, and this field contains all arguments of the original method.",24,null],[12,"allows_variadic_arguments","","Whether the argument list is terminated with \"...\"",24,null],[12,"include_file","","File name of the include file where the method is defined (without full path)",24,null],[12,"origin_location","","Exact location of declaration of the method. Can be None if the method is generated automatically and doesn't have corresponding C++ declaration.",24,null],[12,"template_arguments","","Names of the method's template arguments. None if this is not a template method. If the method belongs to a template class, the class's template arguments are not included here.",24,null],[12,"template_arguments_values","","For an instantiated template method, this field contains the types used for instantiation. For example, `T QObject::findChild<T>()` would have no `template_arguments_values` because it's not instantiated, and `QWidget* QObject::findChild<QWidget*>()` would have `QWidget*` type in `template_arguments_values`.",24,null],[12,"declaration_code","","C++ code of the method's declaration. None if the method was not explicitly declared.",24,null],[12,"inheritance_chain","","List of base classes this method was inferited from. The first item is the most base class.",24,null],[12,"is_fake_inherited_method","","If true, this method was not declared in headers but added in the generator's preprocessing step.",24,null],[12,"doc","","C++ documentation data for this method",24,null],[12,"is_ffi_whitelisted","","If true, FFI generator skips some checks",24,null],[12,"is_unsafe_static_cast","","If true, this is an unsafe (from base to derived) `static_cast` wrapper.",24,null],[12,"is_direct_static_cast","","If true, this is a wrapper of `static_cast` between a class and its direct base.",24,null],[4,"CppOperator","","Available types of C++ operators",null,null],[13,"Conversion","","(type) a",25,null],[13,"Assignment","","a = b",25,null],[13,"Addition","","a + b",25,null],[13,"Subtraction","","a - b",25,null],[13,"UnaryPlus","","+a",25,null],[13,"UnaryMinus","","-a",25,null],[13,"Multiplication","","a * b",25,null],[13,"Division","","a / b",25,null],[13,"Modulo","","a % b",25,null],[13,"PrefixIncrement","","++a",25,null],[13,"PostfixIncrement","","a++",25,null],[13,"PrefixDecrement","","--a",25,null],[13,"PostfixDecrement","","a--",25,null],[13,"EqualTo","","a == b",25,null],[13,"NotEqualTo","","a != b",25,null],[13,"GreaterThan","","a > b",25,null],[13,"LessThan","","a < b",25,null],[13,"GreaterThanOrEqualTo","","a >= b",25,null],[13,"LessThanOrEqualTo","","a <= b",25,null],[13,"LogicalNot","","!a",25,null],[13,"LogicalAnd","","a && b",25,null],[13,"LogicalOr","","a || b",25,null],[13,"BitwiseNot","","~a",25,null],[13,"BitwiseAnd","","a & b",25,null],[13,"BitwiseOr","","a | b",25,null],[13,"BitwiseXor","","a ^ b",25,null],[13,"BitwiseLeftShift","","a << b",25,null],[13,"BitwiseRightShift","","a >> b",25,null],[13,"AdditionAssignment","","a += b",25,null],[13,"SubtractionAssignment","","a -= b",25,null],[13,"MultiplicationAssignment","","a *= b",25,null],[13,"DivisionAssignment","","a /= b",25,null],[13,"ModuloAssignment","","a %= b",25,null],[13,"BitwiseAndAssignment","","a &= b",25,null],[13,"BitwiseOrAssignment","","a |= b",25,null],[13,"BitwiseXorAssignment","","a ^= b",25,null],[13,"BitwiseLeftShiftAssignment","","a <<= b",25,null],[13,"BitwiseRightShiftAssignment","","a >>= b",25,null],[13,"Subscript","","a[b]",25,null],[13,"Indirection","","*a",25,null],[13,"AddressOf","","&a",25,null],[13,"StructureDereference","","a->b",25,null],[13,"PointerToMember","","a->*b",25,null],[13,"FunctionCall","","a(a1, a2)",25,null],[13,"Comma","","a, b",25,null],[13,"New","","new type",25,null],[13,"NewArray","","new type[n]",25,null],[13,"Delete","","delete a",25,null],[13,"DeleteArray","","delete[] a",25,null],[4,"CppMethodKind","","Enumerator indicating special cases of C++ methods.",null,null],[13,"Regular","","Just a class method",26,null],[13,"Constructor","","Constructor",26,null],[13,"Destructor","","Destructor",26,null],[4,"CppFieldAccessorType","","Variation of a field accessor method",null,null],[13,"CopyGetter","","Returns copy of the field",27,null],[13,"ConstRefGetter","","Returns const reference to the field",27,null],[13,"MutRefGetter","","Returns mutable reference to the field",27,null],[13,"Setter","","Copies value from its argument to the field",27,null],[4,"FakeCppMethod","","Information about an automatically generated method",null,null],[13,"FieldAccessor","","Method for accessing a public field of a class",28,null],[12,"accessor_type","cpp_to_rust_generator::cpp_method::FakeCppMethod","",28,null],[12,"field_name","","",28,null],[4,"ReturnValueAllocationPlace","cpp_to_rust_generator::cpp_method","Chosen type allocation place for the method",null,null],[13,"Stack","","The method returns a class object by value (or is a constructor), and it's translated to \"output\" FFI argument and placement new",29,null],[13,"Heap","","The method returns a class object by value (or is a constructor), and it's translated to pointer FFI return type and plain new",29,null],[13,"NotApplicable","","The method does not return a class object by value, so the direct equivalent of the value is used in FFI.",29,null],[11,"fmt","","",20,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",20,{"inputs":[{"name":"self"},{"name":"cppfunctionargument"}],"output":{"name":"bool"}}],[11,"ne","","",20,{"inputs":[{"name":"self"},{"name":"cppfunctionargument"}],"output":{"name":"bool"}}],[11,"clone","","",20,{"inputs":[{"name":"self"}],"output":{"name":"cppfunctionargument"}}],[11,"hash","","",20,null],[11,"fmt","","",26,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",26,{"inputs":[{"name":"self"},{"name":"cppmethodkind"}],"output":{"name":"bool"}}],[11,"clone","","",26,{"inputs":[{"name":"self"}],"output":{"name":"cppmethodkind"}}],[11,"hash","","",26,null],[11,"fmt","","",27,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",27,{"inputs":[{"name":"self"},{"name":"cppfieldaccessortype"}],"output":{"name":"bool"}}],[11,"clone","","",27,{"inputs":[{"name":"self"}],"output":{"name":"cppfieldaccessortype"}}],[11,"hash","","",27,null],[11,"fmt","","",28,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",28,{"inputs":[{"name":"self"},{"name":"fakecppmethod"}],"output":{"name":"bool"}}],[11,"ne","","",28,{"inputs":[{"name":"self"},{"name":"fakecppmethod"}],"output":{"name":"bool"}}],[11,"clone","","",28,{"inputs":[{"name":"self"}],"output":{"name":"fakecppmethod"}}],[11,"hash","","",28,null],[11,"fmt","","",21,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",21,{"inputs":[{"name":"self"},{"name":"cppfieldaccessor"}],"output":{"name":"bool"}}],[11,"ne","","",21,{"inputs":[{"name":"self"},{"name":"cppfieldaccessor"}],"output":{"name":"bool"}}],[11,"clone","","",21,{"inputs":[{"name":"self"}],"output":{"name":"cppfieldaccessor"}}],[11,"hash","","",21,null],[11,"fmt","","",22,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",22,{"inputs":[{"name":"self"},{"name":"cppmethodclassmembership"}],"output":{"name":"bool"}}],[11,"ne","","",22,{"inputs":[{"name":"self"},{"name":"cppmethodclassmembership"}],"output":{"name":"bool"}}],[11,"clone","","",22,{"inputs":[{"name":"self"}],"output":{"name":"cppmethodclassmembership"}}],[11,"hash","","",22,null],[11,"fmt","","",23,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",23,{"inputs":[{"name":"self"},{"name":"cppmethoddoc"}],"output":{"name":"bool"}}],[11,"ne","","",23,{"inputs":[{"name":"self"},{"name":"cppmethoddoc"}],"output":{"name":"bool"}}],[11,"clone","","",23,{"inputs":[{"name":"self"}],"output":{"name":"cppmethoddoc"}}],[11,"hash","","",23,null],[11,"fmt","","",24,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",24,{"inputs":[{"name":"self"},{"name":"cppmethod"}],"output":{"name":"bool"}}],[11,"ne","","",24,{"inputs":[{"name":"self"},{"name":"cppmethod"}],"output":{"name":"bool"}}],[11,"clone","","",24,{"inputs":[{"name":"self"}],"output":{"name":"cppmethod"}}],[11,"hash","","",24,null],[11,"fmt","","",29,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",29,{"inputs":[{"name":"self"},{"name":"returnvalueallocationplace"}],"output":{"name":"bool"}}],[11,"clone","","",29,{"inputs":[{"name":"self"}],"output":{"name":"returnvalueallocationplace"}}],[11,"hash","","",29,null],[11,"is_constructor","","Returns true if this method is a constructor",26,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_destructor","","Returns true if this method is a destructor",26,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_regular","","Returns true if this method is a regular method or a free function",26,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"argument_types_equal","","Checks if two methods have exactly the same set of input argument types",24,{"inputs":[{"name":"self"},{"name":"cppmethod"}],"output":{"name":"bool"}}],[11,"c_signature","","Creates FFI method signature for this method: - converts all types to FFI types; - adds \"this\" argument explicitly if present; - adds \"output\" argument for return value if `allocation_place` is `Stack`.",24,{"inputs":[{"name":"self"},{"name":"returnvalueallocationplace"}],"output":{"name":"result"}}],[11,"to_ffi_signature","","Generates the FFI function signature for this method.",24,{"inputs":[{"name":"self"},{"name":"cppdata"},{"name":"option"}],"output":{"name":"result"}}],[11,"full_name","","Returns fully qualified C++ name of this method, i.e. including namespaces and class name (if any). This method is not suitable for code generation.",24,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"doc_id","","Returns the identifier this method would be presented with in Qt documentation.",24,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"short_text","","Returns short text representing values in this method (only for debugging output).",24,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"inheritance_chain_text","","Returns debugging output for `inheritance_chain` content.",24,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"class_name","","Returns name of the class this method belongs to, if any.",24,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"is_constructor","","Returns true if this method is a constructor.",24,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_destructor","","Returns true if this method is a destructor.",24,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"class_info_if_constructor","","A convenience method. Returns `class_membership` if the method is a constructor, and `None` otherwise.",24,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"receiver_id","","Returns the identifier that should be used in `QObject::connect` to specify this signal or slot.",24,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"is_operator","","Returns true if this method is an operator.",24,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"all_involved_types","","Returns collection of all types found in the signature of this method, including argument types, return type and type of `this` implicit parameter.",24,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[0,"cpp_type","cpp_to_rust_generator","Types for handling information about C++ types.",null,null],[3,"CppTypeClassBase","cpp_to_rust_generator::cpp_type","Information about base C++ class type",null,null],[12,"name","","Name, including namespaces and nested classes",30,null],[12,"template_arguments","","For template classes, C++ types used as template arguments in this type, like [QString, int] in QHash<QString, int>",30,null],[3,"CppFunctionPointerType","","Information about a C++ function pointer type",null,null],[12,"return_type","","Return type of the function",31,null],[12,"arguments","","Arguments of the function",31,null],[12,"allows_variadic_arguments","","Whether arguments are terminated with \"...\"",31,null],[3,"CppSpecificNumericType","","Information about a numeric C++ type that is guaranteed to be the same on all platforms, e.g. `uint32_t`.",null,null],[12,"name","","Type identifier (most likely a typedef name)",32,null],[12,"bits","","Size of type in bits",32,null],[12,"kind","","Information about the type (float or integer, signed or unsigned)",32,null],[3,"CppType","","Information about a C++ type",null,null],[12,"base","","Information about base type",33,null],[12,"indirection","","Indirection applied to base type",33,null],[12,"is_const","","If the type has no indirection, `is_const` indicates constness of the type itself (e.g. `int` vs `const int`). For types that cannot be `const`, `is_const` defaults to `false`. If the type has one level of indirection, `is_const` indicates constness of that indirection, i.e. if the pointer or the reference is const. If the type has two levels of indirection, `is_const` indicates constness of indirection that is applied first.",33,null],[12,"is_const2","","If the type has two levels of indirection, `is_const2` indicates constness of indirection that is applied second. In other cases it is `false`.",33,null],[4,"CppTypeIndirection","","C++ type variants based on indirection",null,null],[13,"None","","No indirection",34,null],[13,"Ptr","","Pointer, like int*",34,null],[13,"Ref","","Reference, like int&",34,null],[13,"PtrRef","","Reference to pointer, like int*&",34,null],[13,"PtrPtr","","Pointer to pointer, like int**",34,null],[13,"RValueRef","","R-value reference, like Class&&",34,null],[4,"CppBuiltInNumericType","","Available built-in C++ numeric types. All these types have corresponding `clang::TypeKind` values (except for `CharS` and `CharU` which map to `CppBuiltInNumericType::Char`)",null,null],[13,"Bool","","",35,null],[13,"Char","","",35,null],[13,"SChar","","",35,null],[13,"UChar","","",35,null],[13,"WChar","","",35,null],[13,"Char16","","",35,null],[13,"Char32","","",35,null],[13,"Short","","",35,null],[13,"UShort","","",35,null],[13,"Int","","",35,null],[13,"UInt","","",35,null],[13,"Long","","",35,null],[13,"ULong","","",35,null],[13,"LongLong","","",35,null],[13,"ULongLong","","",35,null],[13,"Int128","","",35,null],[13,"UInt128","","",35,null],[13,"Float","","",35,null],[13,"Double","","",35,null],[13,"LongDouble","","",35,null],[4,"CppSpecificNumericTypeKind","","Information about a fixed-size primitive type",null,null],[13,"Integer","","",36,null],[12,"is_signed","cpp_to_rust_generator::cpp_type::CppSpecificNumericTypeKind","",36,null],[13,"FloatingPoint","cpp_to_rust_generator::cpp_type","",36,null],[4,"CppTypeBase","","Base C++ type. `CppType` can add indirection and constness to `CppTypeBase`, but otherwise this enum lists all supported types.",null,null],[13,"Void","","Void",37,null],[13,"BuiltInNumeric","","Built-in C++ primitive type, like int",37,null],[13,"SpecificNumeric","","Fixed-size primitive type, like qint64 or int64_t (may be translated to Rust's i64)",37,null],[13,"PointerSizedInteger","","Pointer sized integer, like qintptr (may be translated to Rust's isize)",37,null],[12,"name","cpp_to_rust_generator::cpp_type::CppTypeBase","",37,null],[12,"is_signed","","",37,null],[13,"Enum","cpp_to_rust_generator::cpp_type","Enum type",37,null],[12,"name","cpp_to_rust_generator::cpp_type::CppTypeBase","Name, including namespaces and nested classes",37,null],[13,"Class","cpp_to_rust_generator::cpp_type","Class type",37,null],[13,"TemplateParameter","","Template parameter, like `\"T\"` anywhere inside `QVector<T>` declaration",37,null],[12,"nested_level","cpp_to_rust_generator::cpp_type::CppTypeBase","Template instantiation level. For example, if there is a template class and a template method in it, the class's template parameters will have level = 0 and the method's template parameters will have level = 1. If only the class or only the method is a template, the level will be 0.",37,null],[12,"index","","Index of the parameter. In `QHash<K, V>` `\"K\"` has `index = 0` and `\"V\"` has `index = 1`.",37,null],[13,"FunctionPointer","cpp_to_rust_generator::cpp_type","Function pointer type",37,null],[4,"CppTypeRole","","Context of usage for a C++ type",null,null],[13,"ReturnType","","This type is used as a function's return type",38,null],[13,"NotReturnType","","This type is not used as a function's return type",38,null],[11,"fmt","","",34,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",34,{"inputs":[{"name":"self"},{"name":"cpptypeindirection"}],"output":{"name":"bool"}}],[11,"clone","","",34,{"inputs":[{"name":"self"}],"output":{"name":"cpptypeindirection"}}],[11,"hash","","",34,null],[11,"fmt","","",35,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",35,{"inputs":[{"name":"self"},{"name":"cppbuiltinnumerictype"}],"output":{"name":"bool"}}],[11,"clone","","",35,{"inputs":[{"name":"self"}],"output":{"name":"cppbuiltinnumerictype"}}],[11,"hash","","",35,null],[11,"fmt","","",36,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",36,{"inputs":[{"name":"self"},{"name":"cppspecificnumerictypekind"}],"output":{"name":"bool"}}],[11,"ne","","",36,{"inputs":[{"name":"self"},{"name":"cppspecificnumerictypekind"}],"output":{"name":"bool"}}],[11,"clone","","",36,{"inputs":[{"name":"self"}],"output":{"name":"cppspecificnumerictypekind"}}],[11,"hash","","",36,null],[11,"fmt","","",30,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",30,{"inputs":[{"name":"self"},{"name":"cpptypeclassbase"}],"output":{"name":"bool"}}],[11,"ne","","",30,{"inputs":[{"name":"self"},{"name":"cpptypeclassbase"}],"output":{"name":"bool"}}],[11,"clone","","",30,{"inputs":[{"name":"self"}],"output":{"name":"cpptypeclassbase"}}],[11,"hash","","",30,null],[11,"fmt","","",31,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",31,{"inputs":[{"name":"self"},{"name":"cppfunctionpointertype"}],"output":{"name":"bool"}}],[11,"ne","","",31,{"inputs":[{"name":"self"},{"name":"cppfunctionpointertype"}],"output":{"name":"bool"}}],[11,"clone","","",31,{"inputs":[{"name":"self"}],"output":{"name":"cppfunctionpointertype"}}],[11,"hash","","",31,null],[11,"fmt","","",32,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",32,{"inputs":[{"name":"self"}],"output":{"name":"cppspecificnumerictype"}}],[11,"hash","","",32,null],[11,"fmt","","",37,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",37,{"inputs":[{"name":"self"},{"name":"cpptypebase"}],"output":{"name":"bool"}}],[11,"ne","","",37,{"inputs":[{"name":"self"},{"name":"cpptypebase"}],"output":{"name":"bool"}}],[11,"clone","","",37,{"inputs":[{"name":"self"}],"output":{"name":"cpptypebase"}}],[11,"hash","","",37,null],[11,"fmt","","",33,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",33,{"inputs":[{"name":"self"},{"name":"cpptype"}],"output":{"name":"bool"}}],[11,"ne","","",33,{"inputs":[{"name":"self"},{"name":"cpptype"}],"output":{"name":"bool"}}],[11,"clone","","",33,{"inputs":[{"name":"self"}],"output":{"name":"cpptype"}}],[11,"hash","","",33,null],[11,"combine","","Returns the result of applying `left` to `right`.",34,{"inputs":[{"name":"cpptypeindirection"},{"name":"cpptypeindirection"}],"output":{"name":"result"}}],[11,"to_cpp_code","","Returns C++ code representing this type.",35,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"is_float","","Returns true if this type is some sort of floating point type.",35,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_signed_integer","","Returns true if this type is a signed integer.",35,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_unsigned_integer","","Returns true if this type is an unsigned integer.",35,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_integer_with_undefined_signedness","","Returns true if this type is integer but may be signed or unsigned, depending on the platform.",35,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"all","","Returns all supported types.",35,null],[11,"to_cpp_code","","Returns C++ code representing this type.",30,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"caption","","Returns string representation of this type for the purpose of function name generation.",30,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"instantiate_class","","Attempts to replace template types at `nested_level1` within this type with `template_arguments1`.",30,null],[11,"to_cpp_pseudo_code","","Returns string representation of this type for debugging output.",30,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"is_void","","Returns true if this is `void` type.",37,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_class","","Returns true if this is a class type.",37,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_template_parameter","","Returns true if this is a template parameter.",37,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_function_pointer","","Returns true if this is a function pointer.",37,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_or_contains_template_parameter","","Returns true if this is a template parameter or a type that contains any template parameters.",37,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"to_cpp_code","","Returns C++ code representing this type.",37,{"inputs":[{"name":"self"},{"name":"option"}],"output":{"name":"result"}}],[11,"caption","","Generates alphanumeric representation of self used to generate FFI function names",37,{"inputs":[{"name":"self"},{"name":"typecaptionstrategy"}],"output":{"name":"result"}}],[11,"to_cpp_pseudo_code","","Generates string representation of this type for debugging output.",37,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"fmt","","",38,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",38,{"inputs":[{"name":"self"}],"output":{"name":"cpptyperole"}}],[11,"eq","","",38,{"inputs":[{"name":"self"},{"name":"cpptyperole"}],"output":{"name":"bool"}}],[11,"void","","Creates a `void` type.",33,{"inputs":[],"output":{"name":"self"}}],[11,"is_void","","Returns true if this type is `void`.",33,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"to_cpp_code","","Returns C++ code representing this type.",33,{"inputs":[{"name":"self"},{"name":"option"}],"output":{"name":"result"}}],[11,"to_cpp_pseudo_code","","Returns string representation of this type for debugging output.",33,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"to_cpp_ffi_type","","Converts this C++ type to its adaptation for FFI interface, removing all features not supported by C ABI (e.g. references and passing objects by value).",33,{"inputs":[{"name":"self"},{"name":"cpptyperole"}],"output":{"name":"result"}}],[11,"caption","","Generates alphanumeric representation of self used to generate FFI function names",33,{"inputs":[{"name":"self"},{"name":"typecaptionstrategy"}],"output":{"name":"result"}}],[11,"needs_allocation_place_variants","","Checks if a function with this return type would need to have 2 wrappers with 2 different return value allocation places",33,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"instantiate","","Attempts to replace template types at `nested_level1` within this type with `template_arguments1`.",33,null],[11,"is_platform_dependent","","Returns true if this type is platform dependent. Built-in numeric types that can have different size and/or signedness on different platforms are considered platform dependent. Any types that refer to a platform dependent type are also platform dependent.",33,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"can_be_the_same_as","","Returns true if `self` and `other_type` may theoretically be the same concrete type on some platform. For example, `int` and `long` can be the same, but `int` and `unsigned long` cannot.",33,{"inputs":[{"name":"self"},{"name":"cpptype"}],"output":{"name":"bool"}}],[11,"eq","","",32,{"inputs":[{"name":"self"},{"name":"cppspecificnumerictype"}],"output":{"name":"bool"}}],[11,"fmt","cpp_to_rust_generator::cpp_method","",25,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",25,{"inputs":[{"name":"self"},{"name":"cppoperator"}],"output":{"name":"bool"}}],[11,"ne","","",25,{"inputs":[{"name":"self"},{"name":"cppoperator"}],"output":{"name":"bool"}}],[11,"clone","","",25,{"inputs":[{"name":"self"}],"output":{"name":"cppoperator"}}],[11,"hash","","",25,null],[11,"fmt","","",19,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",19,{"inputs":[{"name":"self"},{"name":"cppoperatorinfo"}],"output":{"name":"bool"}}],[11,"ne","","",19,{"inputs":[{"name":"self"},{"name":"cppoperatorinfo"}],"output":{"name":"bool"}}],[11,"clone","","",19,{"inputs":[{"name":"self"}],"output":{"name":"cppoperatorinfo"}}],[11,"info","","Reports information about this operator",25,{"inputs":[{"name":"self"}],"output":{"name":"cppoperatorinfo"}}],[11,"c_name","","Returns alphanumeric identifier for this operator used to name FFI functions.",25,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"all","","Returns all existing operator kinds except for conversion operator which includes an arbitrary C++ type.",25,{"inputs":[],"output":{"name":"vec"}}]],"paths":[[4,"CacheUsage"],[4,"DebugLoggingConfig"],[3,"CrateDependency"],[3,"CrateProperties"],[3,"Config"],[3,"CppEnumValue"],[3,"CppClassField"],[3,"CppClassUsingDirective"],[3,"CppBaseSpecifier"],[3,"CppOriginLocation"],[3,"CppTypeDoc"],[3,"CppTypeData"],[3,"TemplateArgumentsDeclaration"],[3,"CppTemplateInstantiation"],[3,"CppTemplateInstantiations"],[3,"CppData"],[4,"CppTypeKind"],[4,"CppVisibility"],[4,"CppTypeAllocationPlace"],[3,"CppOperatorInfo"],[3,"CppFunctionArgument"],[3,"CppFieldAccessor"],[3,"CppMethodClassMembership"],[3,"CppMethodDoc"],[3,"CppMethod"],[4,"CppOperator"],[4,"CppMethodKind"],[4,"CppFieldAccessorType"],[4,"FakeCppMethod"],[4,"ReturnValueAllocationPlace"],[3,"CppTypeClassBase"],[3,"CppFunctionPointerType"],[3,"CppSpecificNumericType"],[3,"CppType"],[4,"CppTypeIndirection"],[4,"CppBuiltInNumericType"],[4,"CppSpecificNumericTypeKind"],[4,"CppTypeBase"],[4,"CppTypeRole"]]};
searchIndex["cpp_utils"] = {"doc":"Various C++-related types and functions needed for the `cpp_to_rust` project.","items":[[3,"CppBox","cpp_utils","A C++ pointer wrapper to manage deletion of objects.",null,null],[5,"static_cast","","Converts type of a const pointer using `StaticCast` implementation of the type. If `ptr` is null, this function does nothing and returns null pointer.",null,null],[5,"static_cast_mut","","Converts type of a mutable pointer using `StaticCast` implementation of the type. If `ptr` is null, this function does nothing and returns null pointer.",null,null],[5,"unsafe_static_cast","","Converts type of a const pointer using `UnsafeStaticCast` implementation of the type. `ptr` must be either a null pointer or a valid pointer to an instance of `R` class or a class derived from `R`. If `ptr` is null, this function does nothing and returns null pointer.",null,null],[5,"unsafe_static_cast_mut","","Converts type of a mutable pointer using `UnsafeStaticCast` implementation of the type. `ptr` must be either a null pointer or a valid pointer to an instance of `R` class or a class derived from `R`. If `ptr` is null, this function does nothing and returns null pointer.",null,null],[5,"dynamic_cast","","Converts type of a const pointer using `DynamicCast` implementation of the type. `ptr` must be either a null pointer or a valid pointer to an instance of `T` class or a class derived from `T`. Returns null pointer if `ptr` does not point to an instance of `R` or an instance of a class derived from `R`. If `ptr` is null, this function does nothing and returns null pointer.",null,null],[5,"dynamic_cast_mut","","Converts type of a mutable pointer using `DynamicCast` implementation of the type. `ptr` must be either a null pointer or a valid pointer to an instance of `T` class or a class derived from `T`. Returns null pointer if `ptr` does not point to an instance of `R`. If `ptr` is null, this function does nothing and returns null pointer.",null,null],[0,"new_uninitialized","","This module contains `NewUninitialized` trait. It's an implementation detail of `cpp_to_rust` and should not be used directly.",null,null],[8,"NewUninitialized","cpp_utils::new_uninitialized","A trait for types that can be created with uninitialized internal buffer.",null,null],[10,"new_uninitialized","","Creates new object with uninitialized internal buffer.",0,{"inputs":[],"output":{"name":"self"}}],[6,"Deleter","cpp_utils","Deleter function type.",null,null],[8,"CppDeletable","","Indicates that the type can be put into a CppBox.",null,null],[10,"deleter","","Returns deleter function for this type.",1,{"inputs":[],"output":{"name":"deleter"}}],[8,"StaticCast","","Provides access to C++ `static_cast` conversion from derived class to base class.",null,null],[10,"static_cast","","Convert type of a const reference.",2,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[10,"static_cast_mut","","Convert type of a mutable reference.",2,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[8,"UnsafeStaticCast","","Provides access to C++ `static_cast` conversion from base class to derived class.",null,null],[10,"static_cast","","Convert type of a const reference.",3,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[10,"static_cast_mut","","Convert type of a mutable reference.",3,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[8,"DynamicCast","","Provides access to C++ `dynamic_cast` conversion.",null,null],[10,"dynamic_cast","","Convert type of a const reference. Returns `None` if `self` is not an instance of `T`.",4,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[10,"dynamic_cast_mut","","Convert type of a mutable reference. Returns `None` if `self` is not an instance of `T`.",4,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"as_ptr","","Returns constant raw pointer to the value in the box.",5,null],[11,"as_mut_ptr","","Returns mutable raw pointer to the value in the box.",5,null],[11,"into_raw","","Returns the pointer that was used to create the object and destroys the box. The caller of the function becomes the owner of the object and should ensure that the object will be deleted at some point.",5,null],[11,"is_null","","Returns true if the pointer is null.",5,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"new","","Encapsulates the object into a CppBox.",5,null],[11,"as_ref","","",5,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"as_mut","","",5,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"deref","","",5,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"deref_mut","","",5,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"drop","","",5,{"inputs":[{"name":"self"}],"output":null}],[11,"default","","",5,{"inputs":[],"output":{"name":"cppbox"}}]],"paths":[[8,"NewUninitialized"],[8,"CppDeletable"],[8,"StaticCast"],[8,"UnsafeStaticCast"],[8,"DynamicCast"],[3,"CppBox"]]};
searchIndex["qt_build_tools"] = {"doc":"Implementation of build script for all Qt crates","items":[[5,"run_and_return","qt_build_tools","Runs the build script.",null,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[5,"run","","Runs the build script and exits the process with an appropriate exit code.",null,null]],"paths":[]};
searchIndex["qt_generator_common"] = {"doc":"Common utilities for the generator and the build script for Qt crates.","items":[[3,"InstallationData","qt_generator_common","Properties of a Qt installation",null,null],[12,"qt_version","","Qt version.",0,null],[12,"root_include_path","","Path to the parent include directory of the installation.",0,null],[12,"lib_include_path","","Path to the include directory of the library that is being processed. This is a direct subdirectory of `root_include_path`.",0,null],[12,"lib_path","","Path to the directory containing library files for the linker.",0,null],[12,"docs_path","","Path to the directory containing Qt documentation files.",0,null],[12,"is_framework","","If true, this Qt library was built as a MacOS framework.",0,null],[5,"get_installation_data","","Detects properties of current Qt installation using `qmake` command line utility.",null,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[5,"real_lib_name","","Returns library name of the specified module as should be passed to the linker, e.g. `\"Qt5Core\"`.",null,{"inputs":[{"name":"str"}],"output":{"name":"string"}}],[5,"lib_folder_name","","Returns name of the module's include directory, e.g. `\"QtCore\"`.",null,{"inputs":[{"name":"str"}],"output":{"name":"string"}}],[5,"framework_name","","Returns MacOS framework name of the specified module as should be passed to the linker, e.g. `\"QtCore\"`.",null,{"inputs":[{"name":"str"}],"output":{"name":"string"}}],[5,"lib_dependencies","","Returns list of modules this module depends on.",null,{"inputs":[{"name":"str"}],"output":{"name":"result"}}]],"paths":[[3,"InstallationData"]]};
initSearch(searchIndex);
