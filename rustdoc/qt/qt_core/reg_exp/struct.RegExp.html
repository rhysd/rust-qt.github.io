<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `RegExp` struct in crate `qt_core`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, RegExp">

    <title>qt_core::reg_exp::RegExp - Rust</title>

    <link rel="stylesheet" type="text/css" href="../../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../../main.css">
    

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'><a href='../index.html'>qt_core</a>::<wbr><a href='index.html'>reg_exp</a></p><script>window.sidebarCurrent = {name: 'RegExp', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content struct">
<h1 class='fqn'><span class='in-band'>Struct <a href='../index.html'>qt_core</a>::<wbr><a href='index.html'>reg_exp</a>::<wbr><a class='struct' href=''>RegExp</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a id='src-126596' class='srclink' href='../../src/qt_core/home/ri/rust/rust_qt/cache/qt_core/src/reg_exp.rs.html#54-56' title='goto source code'>[src]</a></span></h1>
<pre class='rust struct'>pub struct RegExp {
    // some fields omitted
}</pre><div class='docblock'><p>C++ type: <span style='color: green;'><code>QRegExp</code></span></p>

<p><a href="http://doc.qt.io/qt-5/qregexp.html">C++ documentation:</a> <div style='border: 1px solid #5CFF95; background: #D6FFE4; padding: 16px;'><p>The <a href="http://doc.qt.io/qt-5/qregexp.html">QRegExp</a> class provides pattern matching using regular expressions.</p>
<p>A regular expression, or &quot;regexp&quot;, is a pattern for matching substrings in a text. This is useful in many contexts, e.g.,</p>
<div class="table"><table class="generic">
 <tbody><tr valign="top" class="odd"><td>Validation</td><td>A regexp can test whether a substring meets some criteria, e.g. is an integer or contains no whitespace.</td></tr>
<tr valign="top" class="even"><td>Searching</td><td>A regexp provides more powerful pattern matching than simple substring matching, e.g., match one of the words <i>mail</i>, <i>letter</i> or <i>correspondence</i>, but none of the words <i>email</i>, <i>mailman</i>, <i>mailer</i>, <i>letterbox</i>, etc.</td></tr>
<tr valign="top" class="odd"><td>Search and Replace</td><td>A regexp can replace all occurrences of a substring with a different substring, e.g., replace all occurrences of <i>&amp;</i> with <i>&amp;amp;</i> except where the <i>&amp;</i> is already followed by an <i>amp;</i>.</td></tr>
<tr valign="top" class="even"><td>String Splitting</td><td>A regexp can be used to identify where a string should be split apart, e.g. splitting tab-delimited strings.</td></tr>
</tbody></table></div>
<p>A brief introduction to regexps is presented, a description of Qt&#39;s regexp language, some examples, and the function documentation itself. <a href="http://doc.qt.io/qt-5/qregexp.html">QRegExp</a> is modeled on Perl&#39;s regexp language. It fully supports Unicode. <a href="http://doc.qt.io/qt-5/qregexp.html">QRegExp</a> can also be used in a simpler, <i>wildcard mode</i> that is similar to the functionality found in command shells. The syntax rules used by <a href="http://doc.qt.io/qt-5/qregexp.html">QRegExp</a> can be changed with <a href="http://doc.qt.io/qt-5/qregexp.html#setPatternSyntax">setPatternSyntax</a>(). In particular, the pattern syntax can be set to <a href="http://doc.qt.io/qt-5/qregexp.html#PatternSyntax-enum">QRegExp::FixedString</a>, which means the pattern to be matched is interpreted as a plain string, i.e., special characters (e.g., backslash) are not escaped.</p>
<p>A good text on regexps is <i>Mastering Regular Expressions</i> (Third Edition) by Jeffrey E. F. Friedl, ISBN 0-596-52812-4.</p>
<a name="introduction"></a></div></p>
</div><h2 id='methods'>Methods</h2><h3 class='impl'><span class='in-band'><code>impl <a class='struct' href='../../qt_core/reg_exp/struct.RegExp.html' title='qt_core::reg_exp::RegExp'>RegExp</a></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-126601' class='srclink' href='../../src/qt_core/home/ri/rust/rust_qt/cache/qt_core/src/reg_exp.rs.html#64-514' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.cap' class='method'><code>fn <a href='#method.cap' class='fnname'>cap</a>&lt;'largs,&nbsp;Args&gt;(&amp;'largs self, args: Args) -&gt; Args::ReturnType <span class='where'>where Args: <a class='trait' href='../../qt_core/reg_exp/overloading/trait.RegExpCapArgs.html' title='qt_core::reg_exp::overloading::RegExpCapArgs'>RegExpCapArgs</a>&lt;'largs&gt;</span></code></h4>
<div class='docblock'><p>C++ method: <span style='color: green;'><code>QRegExp::cap</code></span></p>

<p>This is an overloaded function. Available variants:</p>

<p>Rust arguments: <br>1) <code>fn cap(&amp;self, cpp_utils::AsBox) -&gt; cpp_utils::CppBox&lt;::string::String&gt;</code><br>2) <code>fn cap(&amp;self, (libc::c_int, cpp_utils::AsBox)) -&gt; cpp_utils::CppBox&lt;::string::String&gt;</code><br>3) <code>fn cap(&amp;self, cpp_utils::AsStruct) -&gt; ::string::String</code><br>4) <code>fn cap(&amp;self, (libc::c_int, cpp_utils::AsStruct)) -&gt; ::string::String</code><br>
C++ method: <span style='color: green;'><code>QString QRegExp::cap(int nth = ?) const</code></span></p>

<p><a href="http://doc.qt.io/qt-5/qregexp.html#cap">C++ documentation:</a> <div style='border: 1px solid #5CFF95; background: #D6FFE4; padding: 16px;'><p>Returns the text captured by the <i>nth</i> subexpression. The entire match has index 0 and the parenthesized subexpressions have indexes starting from 1 (excluding non-capturing parentheses).</p>
<pre class="cpp"><span class="type"><a href="http://doc.qt.io/qt-5/qregexp.html#QRegExp">QRegExp</a></span> rxlen(<span class="string">&quot;(\d+)(?:\s*)(cm|inch)&quot;</span>);
<span class="type">int</span> pos <span class="operator">=</span> rxlen<span class="operator">.</span><a href="http://doc.qt.io/qt-5/qregexp.html#indexIn">indexIn</a>(<span class="string">&quot;Length: 189cm&quot;</span>);
<span class="keyword">if</span> (pos <span class="operator">&gt;</span> <span class="operator">-</span><span class="number">1</span>) {
&#32;   <span class="type"><a href="http://doc.qt.io/qt-5/qstring.html">QString</a></span> value <span class="operator">=</span> rxlen<span class="operator">.</span>cap(<span class="number">1</span>); <span class="comment">// &quot;189&quot;</span>
&#32;   <span class="type"><a href="http://doc.qt.io/qt-5/qstring.html">QString</a></span> unit <span class="operator">=</span> rxlen<span class="operator">.</span>cap(<span class="number">2</span>);  <span class="comment">// &quot;cm&quot;</span>
&#32;   <span class="comment">// ...</span>
}</pre>
<p>The order of elements matched by cap() is as follows. The first element, cap(0), is the entire matching string. Each subsequent element corresponds to the next capturing open left parentheses. Thus cap(1) is the text of the first capturing parentheses, cap(2) is the text of the second, and so on.</p>
<p><b>See also </b><a href="http://doc.qt.io/qt-5/qregexp.html#capturedTexts">capturedTexts</a>() and <a href="http://doc.qt.io/qt-5/qregexp.html#pos">pos</a>().</p></div></p>
</div><h4 id='method.cap_mut' class='method'><code>fn <a href='#method.cap_mut' class='fnname'>cap_mut</a>&lt;'largs,&nbsp;Args&gt;(&amp;'largs mut self, args: Args) -&gt; Args::ReturnType <span class='where'>where Args: <a class='trait' href='../../qt_core/reg_exp/overloading/trait.RegExpCapMutArgs.html' title='qt_core::reg_exp::overloading::RegExpCapMutArgs'>RegExpCapMutArgs</a>&lt;'largs&gt;</span></code></h4>
<div class='docblock'><p>C++ method: <span style='color: green;'><code>QRegExp::cap</code></span></p>

<p>This is an overloaded function. Available variants:</p>

<p>Rust arguments: <br>1) <code>fn cap_mut(&amp;mut self, cpp_utils::AsBox) -&gt; cpp_utils::CppBox&lt;::string::String&gt;</code><br>2) <code>fn cap_mut(&amp;mut self, (libc::c_int, cpp_utils::AsBox)) -&gt; cpp_utils::CppBox&lt;::string::String&gt;</code><br>3) <code>fn cap_mut(&amp;mut self, cpp_utils::AsStruct) -&gt; ::string::String</code><br>4) <code>fn cap_mut(&amp;mut self, (libc::c_int, cpp_utils::AsStruct)) -&gt; ::string::String</code><br>
C++ method: <span style='color: green;'><code>QString QRegExp::cap(int nth = ?)</code></span></p>

<p><a href="http://doc.qt.io/qt-5/qregexp.html#cap">C++ documentation:</a> <div style='border: 1px solid #5CFF95; background: #D6FFE4; padding: 16px;'><p>Returns the text captured by the <i>nth</i> subexpression. The entire match has index 0 and the parenthesized subexpressions have indexes starting from 1 (excluding non-capturing parentheses).</p>
<pre class="cpp"><span class="type"><a href="http://doc.qt.io/qt-5/qregexp.html#QRegExp">QRegExp</a></span> rxlen(<span class="string">&quot;(\d+)(?:\s*)(cm|inch)&quot;</span>);
<span class="type">int</span> pos <span class="operator">=</span> rxlen<span class="operator">.</span><a href="http://doc.qt.io/qt-5/qregexp.html#indexIn">indexIn</a>(<span class="string">&quot;Length: 189cm&quot;</span>);
<span class="keyword">if</span> (pos <span class="operator">&gt;</span> <span class="operator">-</span><span class="number">1</span>) {
&#32;   <span class="type"><a href="http://doc.qt.io/qt-5/qstring.html">QString</a></span> value <span class="operator">=</span> rxlen<span class="operator">.</span>cap(<span class="number">1</span>); <span class="comment">// &quot;189&quot;</span>
&#32;   <span class="type"><a href="http://doc.qt.io/qt-5/qstring.html">QString</a></span> unit <span class="operator">=</span> rxlen<span class="operator">.</span>cap(<span class="number">2</span>);  <span class="comment">// &quot;cm&quot;</span>
&#32;   <span class="comment">// ...</span>
}</pre>
<p>The order of elements matched by cap() is as follows. The first element, cap(0), is the entire matching string. Each subsequent element corresponds to the next capturing open left parentheses. Thus cap(1) is the text of the first capturing parentheses, cap(2) is the text of the second, and so on.</p>
<p><b>See also </b><a href="http://doc.qt.io/qt-5/qregexp.html#capturedTexts">capturedTexts</a>() and <a href="http://doc.qt.io/qt-5/qregexp.html#pos">pos</a>().</p></div></p>
</div><h4 id='method.capture_count' class='method'><code>fn <a href='#method.capture_count' class='fnname'>capture_count</a>(&amp;self) -&gt; <a class='type' href='../../libc/type.c_int.html' title='libc::c_int'>c_int</a></code></h4>
<div class='docblock'><p>C++ method: <span style='color: green;'><code>int QRegExp::captureCount() const</code></span></p>

<p><a href="http://doc.qt.io/qt-5/qregexp.html#captureCount">C++ documentation:</a> <div style='border: 1px solid #5CFF95; background: #D6FFE4; padding: 16px;'><p>Returns the number of captures contained in the regular expression.</p>
<p>This function was introduced in  Qt 4.6.</p></div></p>
</div><h4 id='method.captured_texts' class='method'><code>fn <a href='#method.captured_texts' class='fnname'>captured_texts</a>&lt;'largs,&nbsp;Args&gt;(&amp;'largs self, args: Args) -&gt; Args::ReturnType <span class='where'>where Args: <a class='trait' href='../../qt_core/reg_exp/overloading/trait.RegExpCapturedTextsArgs.html' title='qt_core::reg_exp::overloading::RegExpCapturedTextsArgs'>RegExpCapturedTextsArgs</a>&lt;'largs&gt;</span></code></h4>
<div class='docblock'><p>C++ method: <span style='color: green;'><code>QRegExp::capturedTexts</code></span></p>

<p>This is an overloaded function. Available variants:</p>

<p>Rust arguments: <br>1) <code>fn captured_texts(&amp;self, cpp_utils::AsBox) -&gt; cpp_utils::CppBox&lt;::string_list::StringList&gt;</code><br>2) <code>fn captured_texts(&amp;self, cpp_utils::AsStruct) -&gt; ::string_list::StringList</code><br>
C++ method: <span style='color: green;'><code>QStringList QRegExp::capturedTexts() const</code></span></p>

<p><a href="http://doc.qt.io/qt-5/qregexp.html#capturedTexts">C++ documentation:</a> <div style='border: 1px solid #5CFF95; background: #D6FFE4; padding: 16px;'><p>Returns a list of the captured text strings.</p>
<p>The first string in the list is the entire matched string. Each subsequent list element contains a string that matched a (capturing) subexpression of the regexp.</p>
<p>For example:</p>
<pre class="cpp"><span class="type"><a href="http://doc.qt.io/qt-5/qregexp.html#QRegExp">QRegExp</a></span> rx(<span class="string">&quot;(\d+)(\s*)(cm|inch(es)?)&quot;</span>);
<span class="type">int</span> pos <span class="operator">=</span> rx<span class="operator">.</span><a href="http://doc.qt.io/qt-5/qregexp.html#indexIn">indexIn</a>(<span class="string">&quot;Length: 36 inches&quot;</span>);
<span class="type"><a href="http://doc.qt.io/qt-5/qstringlist.html">QStringList</a></span> list <span class="operator">=</span> rx<span class="operator">.</span>capturedTexts();
<span class="comment">// list is now (&quot;36 inches&quot;, &quot;36&quot;, &quot; &quot;, &quot;inches&quot;, &quot;es&quot;)</span></pre>
<p>The above example also captures elements that may be present but which we have no interest in. This problem can be solved by using non-capturing parentheses:</p>
<pre class="cpp"><span class="type"><a href="http://doc.qt.io/qt-5/qregexp.html#QRegExp">QRegExp</a></span> rx(<span class="string">&quot;(\d+)(?:\s*)(cm|inch(?:es)?)&quot;</span>);
<span class="type">int</span> pos <span class="operator">=</span> rx<span class="operator">.</span><a href="http://doc.qt.io/qt-5/qregexp.html#indexIn">indexIn</a>(<span class="string">&quot;Length: 36 inches&quot;</span>);
<span class="type"><a href="http://doc.qt.io/qt-5/qstringlist.html">QStringList</a></span> list <span class="operator">=</span> rx<span class="operator">.</span>capturedTexts();
<span class="comment">// list is now (&quot;36 inches&quot;, &quot;36&quot;, &quot;inches&quot;)</span></pre>
<p>Note that if you want to iterate over the list, you should iterate over a copy, e.g.</p>
<pre class="cpp"><span class="type"><a href="http://doc.qt.io/qt-5/qstringlist.html">QStringList</a></span> list <span class="operator">=</span> rx<span class="operator">.</span>capturedTexts();
<span class="type"><a href="http://doc.qt.io/qt-5/qstringlist.html">QStringList</a></span><span class="operator">::</span>iterator it <span class="operator">=</span> list<span class="operator">.</span>begin();
<span class="keyword">while</span> (it <span class="operator">!</span><span class="operator">=</span> list<span class="operator">.</span>end()) {
&#32;   myProcessing(<span class="operator">*</span>it);
&#32;   <span class="operator">+</span><span class="operator">+</span>it;
}</pre>
<p>Some regexps can match an indeterminate number of times. For example if the input string is &quot;Offsets: 12 14 99 231 7&quot; and the regexp, <code>rx</code>, is <b>(\d+)+</b>, we would hope to get a list of all the numbers matched. However, after calling <code>rx.indexIn(str)</code>, capturedTexts() will return the list (&quot;12&quot;, &quot;12&quot;), i.e. the entire match was &quot;12&quot; and the first subexpression matched was &quot;12&quot;. The correct approach is to use <a href="http://doc.qt.io/qt-5/qregexp.html#cap">cap</a>() in a <a href="http://doc.qt.io/qt-5/qregexp.html#cap-in-a-loop">loop</a>.</p>
<p>The order of elements in the string list is as follows. The first element is the entire matching string. Each subsequent element corresponds to the next capturing open left parentheses. Thus capturedTexts()[1] is the text of the first capturing parentheses, capturedTexts()[2] is the text of the second and so on (corresponding to $1, $2, etc., in some other regexp languages).</p>
<p><b>See also </b><a href="http://doc.qt.io/qt-5/qregexp.html#cap">cap</a>() and <a href="http://doc.qt.io/qt-5/qregexp.html#pos">pos</a>().</p></div></p>
</div><h4 id='method.captured_texts_mut' class='method'><code>fn <a href='#method.captured_texts_mut' class='fnname'>captured_texts_mut</a>&lt;'largs,&nbsp;Args&gt;(&amp;'largs mut self, args: Args) -&gt; Args::ReturnType <span class='where'>where Args: <a class='trait' href='../../qt_core/reg_exp/overloading/trait.RegExpCapturedTextsMutArgs.html' title='qt_core::reg_exp::overloading::RegExpCapturedTextsMutArgs'>RegExpCapturedTextsMutArgs</a>&lt;'largs&gt;</span></code></h4>
<div class='docblock'><p>C++ method: <span style='color: green;'><code>QRegExp::capturedTexts</code></span></p>

<p>This is an overloaded function. Available variants:</p>

<p>Rust arguments: <br>1) <code>fn captured_texts_mut(&amp;mut self, cpp_utils::AsBox) -&gt; cpp_utils::CppBox&lt;::string_list::StringList&gt;</code><br>2) <code>fn captured_texts_mut(&amp;mut self, cpp_utils::AsStruct) -&gt; ::string_list::StringList</code><br>
C++ method: <span style='color: green;'><code>QStringList QRegExp::capturedTexts()</code></span></p>

<p><a href="http://doc.qt.io/qt-5/qregexp.html#capturedTexts">C++ documentation:</a> <div style='border: 1px solid #5CFF95; background: #D6FFE4; padding: 16px;'><p>Returns a list of the captured text strings.</p>
<p>The first string in the list is the entire matched string. Each subsequent list element contains a string that matched a (capturing) subexpression of the regexp.</p>
<p>For example:</p>
<pre class="cpp"><span class="type"><a href="http://doc.qt.io/qt-5/qregexp.html#QRegExp">QRegExp</a></span> rx(<span class="string">&quot;(\d+)(\s*)(cm|inch(es)?)&quot;</span>);
<span class="type">int</span> pos <span class="operator">=</span> rx<span class="operator">.</span><a href="http://doc.qt.io/qt-5/qregexp.html#indexIn">indexIn</a>(<span class="string">&quot;Length: 36 inches&quot;</span>);
<span class="type"><a href="http://doc.qt.io/qt-5/qstringlist.html">QStringList</a></span> list <span class="operator">=</span> rx<span class="operator">.</span>capturedTexts();
<span class="comment">// list is now (&quot;36 inches&quot;, &quot;36&quot;, &quot; &quot;, &quot;inches&quot;, &quot;es&quot;)</span></pre>
<p>The above example also captures elements that may be present but which we have no interest in. This problem can be solved by using non-capturing parentheses:</p>
<pre class="cpp"><span class="type"><a href="http://doc.qt.io/qt-5/qregexp.html#QRegExp">QRegExp</a></span> rx(<span class="string">&quot;(\d+)(?:\s*)(cm|inch(?:es)?)&quot;</span>);
<span class="type">int</span> pos <span class="operator">=</span> rx<span class="operator">.</span><a href="http://doc.qt.io/qt-5/qregexp.html#indexIn">indexIn</a>(<span class="string">&quot;Length: 36 inches&quot;</span>);
<span class="type"><a href="http://doc.qt.io/qt-5/qstringlist.html">QStringList</a></span> list <span class="operator">=</span> rx<span class="operator">.</span>capturedTexts();
<span class="comment">// list is now (&quot;36 inches&quot;, &quot;36&quot;, &quot;inches&quot;)</span></pre>
<p>Note that if you want to iterate over the list, you should iterate over a copy, e.g.</p>
<pre class="cpp"><span class="type"><a href="http://doc.qt.io/qt-5/qstringlist.html">QStringList</a></span> list <span class="operator">=</span> rx<span class="operator">.</span>capturedTexts();
<span class="type"><a href="http://doc.qt.io/qt-5/qstringlist.html">QStringList</a></span><span class="operator">::</span>iterator it <span class="operator">=</span> list<span class="operator">.</span>begin();
<span class="keyword">while</span> (it <span class="operator">!</span><span class="operator">=</span> list<span class="operator">.</span>end()) {
&#32;   myProcessing(<span class="operator">*</span>it);
&#32;   <span class="operator">+</span><span class="operator">+</span>it;
}</pre>
<p>Some regexps can match an indeterminate number of times. For example if the input string is &quot;Offsets: 12 14 99 231 7&quot; and the regexp, <code>rx</code>, is <b>(\d+)+</b>, we would hope to get a list of all the numbers matched. However, after calling <code>rx.indexIn(str)</code>, capturedTexts() will return the list (&quot;12&quot;, &quot;12&quot;), i.e. the entire match was &quot;12&quot; and the first subexpression matched was &quot;12&quot;. The correct approach is to use <a href="http://doc.qt.io/qt-5/qregexp.html#cap">cap</a>() in a <a href="http://doc.qt.io/qt-5/qregexp.html#cap-in-a-loop">loop</a>.</p>
<p>The order of elements in the string list is as follows. The first element is the entire matching string. Each subsequent element corresponds to the next capturing open left parentheses. Thus capturedTexts()[1] is the text of the first capturing parentheses, capturedTexts()[2] is the text of the second and so on (corresponding to $1, $2, etc., in some other regexp languages).</p>
<p><b>See also </b><a href="http://doc.qt.io/qt-5/qregexp.html#cap">cap</a>() and <a href="http://doc.qt.io/qt-5/qregexp.html#pos">pos</a>().</p></div></p>
</div><h4 id='method.case_sensitivity' class='method'><code>fn <a href='#method.case_sensitivity' class='fnname'>case_sensitivity</a>(&amp;self) -&gt; <a class='enum' href='../../qt_core/qt/enum.CaseSensitivity.html' title='qt_core::qt::CaseSensitivity'>CaseSensitivity</a></code></h4>
<div class='docblock'><p>C++ method: <span style='color: green;'><code>Qt::CaseSensitivity QRegExp::caseSensitivity() const</code></span></p>

<p><a href="http://doc.qt.io/qt-5/qregexp.html#caseSensitivity">C++ documentation:</a> <div style='border: 1px solid #5CFF95; background: #D6FFE4; padding: 16px;'><p>Returns <a href="http://doc.qt.io/qt-5/qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a> if the regexp is matched case sensitively; otherwise returns <a href="http://doc.qt.io/qt-5/qt.html#CaseSensitivity-enum">Qt::CaseInsensitive</a>.</p>
<p><b>See also </b><a href="http://doc.qt.io/qt-5/qregexp.html#setCaseSensitivity">setCaseSensitivity</a>(), <a href="http://doc.qt.io/qt-5/qregexp.html#patternSyntax">patternSyntax</a>(), <a href="http://doc.qt.io/qt-5/qregexp.html#pattern">pattern</a>(), and <a href="http://doc.qt.io/qt-5/qregexp.html#isMinimal">isMinimal</a>().</p></div></p>
</div><h4 id='method.error_string' class='method'><code>fn <a href='#method.error_string' class='fnname'>error_string</a>&lt;'largs,&nbsp;Args&gt;(&amp;'largs self, args: Args) -&gt; Args::ReturnType <span class='where'>where Args: <a class='trait' href='../../qt_core/reg_exp/overloading/trait.RegExpErrorStringArgs.html' title='qt_core::reg_exp::overloading::RegExpErrorStringArgs'>RegExpErrorStringArgs</a>&lt;'largs&gt;</span></code></h4>
<div class='docblock'><p>C++ method: <span style='color: green;'><code>QRegExp::errorString</code></span></p>

<p>This is an overloaded function. Available variants:</p>

<p>Rust arguments: <br>1) <code>fn error_string(&amp;self, cpp_utils::AsBox) -&gt; cpp_utils::CppBox&lt;::string::String&gt;</code><br>2) <code>fn error_string(&amp;self, cpp_utils::AsStruct) -&gt; ::string::String</code><br>
C++ method: <span style='color: green;'><code>QString QRegExp::errorString() const</code></span></p>

<p><a href="http://doc.qt.io/qt-5/qregexp.html#errorString">C++ documentation:</a> <div style='border: 1px solid #5CFF95; background: #D6FFE4; padding: 16px;'><p>Returns a text string that explains why a regexp pattern is invalid the case being; otherwise returns &quot;no error occurred&quot;.</p>
<p><b>See also </b><a href="http://doc.qt.io/qt-5/qregexp.html#isValid">isValid</a>().</p></div></p>
</div><h4 id='method.error_string_mut' class='method'><code>fn <a href='#method.error_string_mut' class='fnname'>error_string_mut</a>&lt;'largs,&nbsp;Args&gt;(&amp;'largs mut self, args: Args) -&gt; Args::ReturnType <span class='where'>where Args: <a class='trait' href='../../qt_core/reg_exp/overloading/trait.RegExpErrorStringMutArgs.html' title='qt_core::reg_exp::overloading::RegExpErrorStringMutArgs'>RegExpErrorStringMutArgs</a>&lt;'largs&gt;</span></code></h4>
<div class='docblock'><p>C++ method: <span style='color: green;'><code>QRegExp::errorString</code></span></p>

<p>This is an overloaded function. Available variants:</p>

<p>Rust arguments: <br>1) <code>fn error_string_mut(&amp;mut self, cpp_utils::AsBox) -&gt; cpp_utils::CppBox&lt;::string::String&gt;</code><br>2) <code>fn error_string_mut(&amp;mut self, cpp_utils::AsStruct) -&gt; ::string::String</code><br>
C++ method: <span style='color: green;'><code>QString QRegExp::errorString()</code></span></p>

<p><a href="http://doc.qt.io/qt-5/qregexp.html#errorString">C++ documentation:</a> <div style='border: 1px solid #5CFF95; background: #D6FFE4; padding: 16px;'><p>Returns a text string that explains why a regexp pattern is invalid the case being; otherwise returns &quot;no error occurred&quot;.</p>
<p><b>See also </b><a href="http://doc.qt.io/qt-5/qregexp.html#isValid">isValid</a>().</p></div></p>
</div><h4 id='method.escape' class='method'><code>fn <a href='#method.escape' class='fnname'>escape</a>&lt;Args&gt;(args: Args) -&gt; Args::ReturnType <span class='where'>where Args: <a class='trait' href='../../qt_core/reg_exp/overloading/trait.RegExpEscapeArgs.html' title='qt_core::reg_exp::overloading::RegExpEscapeArgs'>RegExpEscapeArgs</a></span></code></h4>
<div class='docblock'><p>C++ method: <span style='color: green;'><code>QRegExp::escape</code></span></p>

<p>This is an overloaded function. Available variants:</p>

<p>Rust arguments: <br>1) <code>fn escape((&amp;::string::String, cpp_utils::AsBox)) -&gt; cpp_utils::CppBox&lt;::string::String&gt;</code><br>2) <code>fn escape((&amp;::string::String, cpp_utils::AsStruct)) -&gt; ::string::String</code><br>
C++ method: <span style='color: green;'><code>static QString QRegExp::escape(const QString&amp; str)</code></span></p>

<p><a href="http://doc.qt.io/qt-5/qregexp.html#escape">C++ documentation:</a> <div style='border: 1px solid #5CFF95; background: #D6FFE4; padding: 16px;'><p>Returns the string <i>str</i> with every regexp special character escaped with a backslash. The special characters are $, (,), *, +, ., ?, [, ,], <sup>,</sup> {, | and }.</p>
<p>Example:</p>
<pre class="cpp">s1 <span class="operator">=</span> <span class="type"><a href="http://doc.qt.io/qt-5/qregexp.html#QRegExp">QRegExp</a></span><span class="operator">::</span>escape(<span class="string">&quot;bingo&quot;</span>);   <span class="comment">// s1 == &quot;bingo&quot;</span>
s2 <span class="operator">=</span> <span class="type"><a href="http://doc.qt.io/qt-5/qregexp.html#QRegExp">QRegExp</a></span><span class="operator">::</span>escape(<span class="string">&quot;f(x)&quot;</span>);    <span class="comment">// s2 == &quot;f\(x\)&quot;</span></pre>
<p>This function is useful to construct regexp patterns dynamically:</p>
<pre class="cpp"><span class="type"><a href="http://doc.qt.io/qt-5/qregexp.html#QRegExp">QRegExp</a></span> rx(<span class="string">&quot;(&quot;</span> <span class="operator">+</span> <span class="type"><a href="http://doc.qt.io/qt-5/qregexp.html#QRegExp">QRegExp</a></span><span class="operator">::</span>escape(name) <span class="operator">+</span>
&#32;          <span class="string">&quot;|&quot;</span> <span class="operator">+</span> <span class="type"><a href="http://doc.qt.io/qt-5/qregexp.html#QRegExp">QRegExp</a></span><span class="operator">::</span>escape(alias) <span class="operator">+</span> <span class="string">&quot;)&quot;</span>);</pre>
<p><b>See also </b><a href="http://doc.qt.io/qt-5/qregexp.html#setPatternSyntax">setPatternSyntax</a>().</p></div></p>
</div><h4 id='method.exact_match' class='method'><code>fn <a href='#method.exact_match' class='fnname'>exact_match</a>(&amp;self, str: &amp;<a class='struct' href='../../qt_core/string/struct.String.html' title='qt_core::string::String'>String</a>) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>C++ method: <span style='color: green;'><code>bool QRegExp::exactMatch(const QString&amp; str) const</code></span></p>

<p><a href="http://doc.qt.io/qt-5/qregexp.html#exactMatch">C++ documentation:</a> <div style='border: 1px solid #5CFF95; background: #D6FFE4; padding: 16px;'><p>Returns <code>true</code> if <i>str</i> is matched exactly by this regular expression; otherwise returns <code>false</code>. You can determine how much of the string was matched by calling <a href="http://doc.qt.io/qt-5/qregexp.html#matchedLength">matchedLength</a>().</p>
<p>For a given regexp string R, exactMatch(&quot;R&quot;) is the equivalent of <a href="http://doc.qt.io/qt-5/qregexp.html#indexIn">indexIn</a>(&quot;<sup>R$&quot;)</sup> since exactMatch() effectively encloses the regexp in the start of string and end of string anchors, except that it sets <a href="http://doc.qt.io/qt-5/qregexp.html#matchedLength">matchedLength</a>() differently.</p>
<p>For example, if the regular expression is <b>blue</b>, then exactMatch() returns <code>true</code> only for input <code>blue</code>. For inputs <code>bluebell</code>, <code>blutak</code> and <code>lightblue</code>, exactMatch() returns <code>false</code> and <a href="http://doc.qt.io/qt-5/qregexp.html#matchedLength">matchedLength</a>() will return 4, 3 and 0 respectively.</p>
<p>Although const, this function sets <a href="http://doc.qt.io/qt-5/qregexp.html#matchedLength">matchedLength</a>(), <a href="http://doc.qt.io/qt-5/qregexp.html#capturedTexts">capturedTexts</a>(), and <a href="http://doc.qt.io/qt-5/qregexp.html#pos">pos</a>().</p>
<p><b>See also </b><a href="http://doc.qt.io/qt-5/qregexp.html#indexIn">indexIn</a>() and <a href="http://doc.qt.io/qt-5/qregexp.html#lastIndexIn">lastIndexIn</a>().</p></div></p>
</div><h4 id='method.index_in' class='method'><code>fn <a href='#method.index_in' class='fnname'>index_in</a>&lt;'largs,&nbsp;Args&gt;(&amp;'largs self, args: Args) -&gt; <a class='type' href='../../libc/type.c_int.html' title='libc::c_int'>c_int</a> <span class='where'>where Args: <a class='trait' href='../../qt_core/reg_exp/overloading/trait.RegExpIndexInArgs.html' title='qt_core::reg_exp::overloading::RegExpIndexInArgs'>RegExpIndexInArgs</a>&lt;'largs&gt;</span></code></h4>
<div class='docblock'><p>C++ method: <span style='color: green;'><code>QRegExp::indexIn</code></span></p>

<p>This is an overloaded function. Available variants:</p>

<p>Rust arguments: <br>1) <code>fn index_in(&amp;self, &amp;::string::String) -&gt; libc::c_int</code><br>2) <code>fn index_in(&amp;self, (&amp;::string::String, libc::c_int)) -&gt; libc::c_int</code><br>3) <code>fn index_in(&amp;self, (&amp;::string::String, libc::c_int, ::reg_exp::CaretMode)) -&gt; libc::c_int</code><br>
C++ method: <span style='color: green;'><code>int QRegExp::indexIn(const QString&amp; str, int offset = ?, QRegExp::CaretMode caretMode = ?) const</code></span></p>

<p><a href="http://doc.qt.io/qt-5/qregexp.html#indexIn">C++ documentation:</a> <div style='border: 1px solid #5CFF95; background: #D6FFE4; padding: 16px;'><p>Attempts to find a match in <i>str</i> from position <i>offset</i> (0 by default). If <i>offset</i> is -1, the search starts at the last character; if -2, at the next to last character; etc.</p>
<p>Returns the position of the first match, or -1 if there was no match.</p>
<p>The <i>caretMode</i> parameter can be used to instruct whether <b><sup></b></sup> should match at index 0 or at <i>offset</i>.</p>
<p>You might prefer to use <a href="http://doc.qt.io/qt-5/qstring.html#indexOf">QString::indexOf</a>(), <a href="http://doc.qt.io/qt-5/qstring.html#contains">QString::contains</a>(), or even <a href="http://doc.qt.io/qt-5/qstringlist.html#filter">QStringList::filter</a>(). To replace matches use <a href="http://doc.qt.io/qt-5/qstring.html#replace">QString::replace</a>().</p>
<p>Example:</p>
<pre class="cpp"><span class="type"><a href="http://doc.qt.io/qt-5/qstring.html">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;offsets: 1.23 .50 71.00 6.00&quot;</span>;
<span class="type"><a href="http://doc.qt.io/qt-5/qregexp.html#QRegExp">QRegExp</a></span> rx(<span class="string">&quot;\d*\.\d+&quot;</span>);    <span class="comment">// primitive floating point matching</span>
<span class="type">int</span> count <span class="operator">=</span> <span class="number">0</span>;
<span class="type">int</span> pos <span class="operator">=</span> <span class="number">0</span>;
<span class="keyword">while</span> ((pos <span class="operator">=</span> rx<span class="operator">.</span>indexIn(str<span class="operator">,</span> pos)) <span class="operator">!</span><span class="operator">=</span> <span class="operator">-</span><span class="number">1</span>) {
&#32;   <span class="operator">+</span><span class="operator">+</span>count;
&#32;   pos <span class="operator">+</span><span class="operator">=</span> rx<span class="operator">.</span>matchedLength();
}
<span class="comment">// pos will be 9, 14, 18 and finally 24; count will end up as 4</span></pre>
<p>Although const, this function sets <a href="http://doc.qt.io/qt-5/qregexp.html#matchedLength">matchedLength</a>(), <a href="http://doc.qt.io/qt-5/qregexp.html#capturedTexts">capturedTexts</a>() and <a href="http://doc.qt.io/qt-5/qregexp.html#pos">pos</a>().</p>
<p>If the <a href="http://doc.qt.io/qt-5/qregexp.html">QRegExp</a> is a wildcard expression (see <a href="http://doc.qt.io/qt-5/qregexp.html#setPatternSyntax">setPatternSyntax</a>()) and want to test a string against the whole wildcard expression, use <a href="http://doc.qt.io/qt-5/qregexp.html#exactMatch">exactMatch</a>() instead of this function.</p>
<p><b>See also </b><a href="http://doc.qt.io/qt-5/qregexp.html#lastIndexIn">lastIndexIn</a>() and <a href="http://doc.qt.io/qt-5/qregexp.html#exactMatch">exactMatch</a>().</p></div></p>
</div><h4 id='method.is_empty' class='method'><code>fn <a href='#method.is_empty' class='fnname'>is_empty</a>(&amp;self) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>C++ method: <span style='color: green;'><code>bool QRegExp::isEmpty() const</code></span></p>

<p><a href="http://doc.qt.io/qt-5/qregexp.html#isEmpty">C++ documentation:</a> <div style='border: 1px solid #5CFF95; background: #D6FFE4; padding: 16px;'><p>Returns <code>true</code> if the pattern string is empty; otherwise returns false.</p>
<p>If you call <a href="http://doc.qt.io/qt-5/qregexp.html#exactMatch">exactMatch</a>() with an empty pattern on an empty string it will return true; otherwise it returns <code>false</code> since it operates over the whole string. If you call <a href="http://doc.qt.io/qt-5/qregexp.html#indexIn">indexIn</a>() with an empty pattern on <i>any</i> string it will return the start offset (0 by default) because the empty pattern matches the &#39;emptiness&#39; at the start of the string. In this case the length of the match returned by <a href="http://doc.qt.io/qt-5/qregexp.html#matchedLength">matchedLength</a>() will be 0.</p>
<p>See <a href="http://doc.qt.io/qt-5/qstring.html#isEmpty">QString::isEmpty</a>().</p></div></p>
</div><h4 id='method.is_minimal' class='method'><code>fn <a href='#method.is_minimal' class='fnname'>is_minimal</a>(&amp;self) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>C++ method: <span style='color: green;'><code>bool QRegExp::isMinimal() const</code></span></p>

<p><a href="http://doc.qt.io/qt-5/qregexp.html#isMinimal">C++ documentation:</a> <div style='border: 1px solid #5CFF95; background: #D6FFE4; padding: 16px;'><p>Returns <code>true</code> if minimal (non-greedy) matching is enabled; otherwise returns <code>false</code>.</p>
<p><b>See also </b><a href="http://doc.qt.io/qt-5/qregexp.html#caseSensitivity">caseSensitivity</a>() and <a href="http://doc.qt.io/qt-5/qregexp.html#setMinimal">setMinimal</a>().</p></div></p>
</div><h4 id='method.is_valid' class='method'><code>fn <a href='#method.is_valid' class='fnname'>is_valid</a>(&amp;self) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>C++ method: <span style='color: green;'><code>bool QRegExp::isValid() const</code></span></p>

<p><a href="http://doc.qt.io/qt-5/qregexp.html#isValid">C++ documentation:</a> <div style='border: 1px solid #5CFF95; background: #D6FFE4; padding: 16px;'><p>Returns <code>true</code> if the regular expression is valid; otherwise returns false. An invalid regular expression never matches.</p>
<p>The pattern <b>[a-z</b> is an example of an invalid pattern, since it lacks a closing square bracket.</p>
<p>Note that the validity of a regexp may also depend on the setting of the wildcard flag, for example <b>*.html</b> is a valid wildcard regexp but an invalid full regexp.</p>
<p><b>See also </b><a href="http://doc.qt.io/qt-5/qregexp.html#errorString">errorString</a>().</p></div></p>
</div><h4 id='method.last_index_in' class='method'><code>fn <a href='#method.last_index_in' class='fnname'>last_index_in</a>&lt;'largs,&nbsp;Args&gt;(&amp;'largs self, args: Args) -&gt; <a class='type' href='../../libc/type.c_int.html' title='libc::c_int'>c_int</a> <span class='where'>where Args: <a class='trait' href='../../qt_core/reg_exp/overloading/trait.RegExpLastIndexInArgs.html' title='qt_core::reg_exp::overloading::RegExpLastIndexInArgs'>RegExpLastIndexInArgs</a>&lt;'largs&gt;</span></code></h4>
<div class='docblock'><p>C++ method: <span style='color: green;'><code>QRegExp::lastIndexIn</code></span></p>

<p>This is an overloaded function. Available variants:</p>

<p>Rust arguments: <br>1) <code>fn last_index_in(&amp;self, &amp;::string::String) -&gt; libc::c_int</code><br>2) <code>fn last_index_in(&amp;self, (&amp;::string::String, libc::c_int)) -&gt; libc::c_int</code><br>3) <code>fn last_index_in(&amp;self, (&amp;::string::String, libc::c_int, ::reg_exp::CaretMode)) -&gt; libc::c_int</code><br>
C++ method: <span style='color: green;'><code>int QRegExp::lastIndexIn(const QString&amp; str, int offset = ?, QRegExp::CaretMode caretMode = ?) const</code></span></p>

<p><a href="http://doc.qt.io/qt-5/qregexp.html#lastIndexIn">C++ documentation:</a> <div style='border: 1px solid #5CFF95; background: #D6FFE4; padding: 16px;'><p>Attempts to find a match backwards in <i>str</i> from position <i>offset</i>. If <i>offset</i> is -1 (the default), the search starts at the last character; if -2, at the next to last character; etc.</p>
<p>Returns the position of the first match, or -1 if there was no match.</p>
<p>The <i>caretMode</i> parameter can be used to instruct whether <b><sup></b></sup> should match at index 0 or at <i>offset</i>.</p>
<p>Although const, this function sets <a href="http://doc.qt.io/qt-5/qregexp.html#matchedLength">matchedLength</a>(), <a href="http://doc.qt.io/qt-5/qregexp.html#capturedTexts">capturedTexts</a>() and <a href="http://doc.qt.io/qt-5/qregexp.html#pos">pos</a>().</p>
<p><b>Warning:</b> Searching backwards is much slower than searching forwards.</p>
<p><b>See also </b><a href="http://doc.qt.io/qt-5/qregexp.html#indexIn">indexIn</a>() and <a href="http://doc.qt.io/qt-5/qregexp.html#exactMatch">exactMatch</a>().</p></div></p>
</div><h4 id='method.matched_length' class='method'><code>fn <a href='#method.matched_length' class='fnname'>matched_length</a>(&amp;self) -&gt; <a class='type' href='../../libc/type.c_int.html' title='libc::c_int'>c_int</a></code></h4>
<div class='docblock'><p>C++ method: <span style='color: green;'><code>int QRegExp::matchedLength() const</code></span></p>

<p><a href="http://doc.qt.io/qt-5/qregexp.html#matchedLength">C++ documentation:</a> <div style='border: 1px solid #5CFF95; background: #D6FFE4; padding: 16px;'><p>Returns the length of the last matched string, or -1 if there was no match.</p>
<p><b>See also </b><a href="http://doc.qt.io/qt-5/qregexp.html#exactMatch">exactMatch</a>(), <a href="http://doc.qt.io/qt-5/qregexp.html#indexIn">indexIn</a>(), and <a href="http://doc.qt.io/qt-5/qregexp.html#lastIndexIn">lastIndexIn</a>().</p></div></p>
</div><h4 id='method.new' class='method'><code>fn <a href='#method.new' class='fnname'>new</a>&lt;Args&gt;(args: Args) -&gt; Args::ReturnType <span class='where'>where Args: <a class='trait' href='../../qt_core/reg_exp/overloading/trait.RegExpNewArgs.html' title='qt_core::reg_exp::overloading::RegExpNewArgs'>RegExpNewArgs</a></span></code></h4>
<div class='docblock'><p>C++ method: <span style='color: green;'><code>QRegExp::QRegExp</code></span></p>

<p>This is an overloaded function. Available variants:</p>

<h2 id='variant-1' class='section-header'><a href='#variant-1'>Variant 1</a></h2>
<p>Rust arguments: <br>1) <code>fn new(cpp_utils::AsStruct) -&gt; ::reg_exp::RegExp</code><br>2) <code>fn new(cpp_utils::AsBox) -&gt; cpp_utils::CppBox&lt;::reg_exp::RegExp&gt;</code><br>
C++ method: <span style='color: green;'><code>[constructor] void QRegExp::QRegExp()</code></span></p>

<h2 id='variant-2' class='section-header'><a href='#variant-2'>Variant 2</a></h2>
<p>Rust arguments: <br>1) <code>fn new((&amp;::reg_exp::RegExp, cpp_utils::AsStruct)) -&gt; ::reg_exp::RegExp</code><br>2) <code>fn new((&amp;::reg_exp::RegExp, cpp_utils::AsBox)) -&gt; cpp_utils::CppBox&lt;::reg_exp::RegExp&gt;</code><br>
C++ method: <span style='color: green;'><code>[constructor] void QRegExp::QRegExp(const QRegExp&amp; rx)</code></span></p>

<h2 id='variant-3' class='section-header'><a href='#variant-3'>Variant 3</a></h2>
<p>Rust arguments: <br>1) <code>fn new((&amp;::string::String, cpp_utils::AsStruct)) -&gt; ::reg_exp::RegExp</code><br>2) <code>fn new((&amp;::string::String, ::qt::CaseSensitivity, cpp_utils::AsStruct)) -&gt; ::reg_exp::RegExp</code><br>3) <code>fn new((&amp;::string::String, ::qt::CaseSensitivity, ::reg_exp::PatternSyntax, cpp_utils::AsStruct)) -&gt; ::reg_exp::RegExp</code><br>4) <code>fn new((&amp;::string::String, cpp_utils::AsBox)) -&gt; cpp_utils::CppBox&lt;::reg_exp::RegExp&gt;</code><br>5) <code>fn new((&amp;::string::String, ::qt::CaseSensitivity, cpp_utils::AsBox)) -&gt; cpp_utils::CppBox&lt;::reg_exp::RegExp&gt;</code><br>6) <code>fn new((&amp;::string::String, ::qt::CaseSensitivity, ::reg_exp::PatternSyntax, cpp_utils::AsBox)) -&gt; cpp_utils::CppBox&lt;::reg_exp::RegExp&gt;</code><br>
C++ method: <span style='color: green;'><code>[constructor] void QRegExp::QRegExp(const QString&amp; pattern, Qt::CaseSensitivity cs = ?, QRegExp::PatternSyntax syntax = ?)</code></span></p>
</div><h4 id='method.op_assign' class='method'><code>fn <a href='#method.op_assign' class='fnname'>op_assign</a>&lt;'l0,&nbsp;'l1&gt;(&amp;'l0 mut self, rx: &amp;'l1 <a class='struct' href='../../qt_core/reg_exp/struct.RegExp.html' title='qt_core::reg_exp::RegExp'>RegExp</a>) -&gt; &amp;'l0 mut <a class='struct' href='../../qt_core/reg_exp/struct.RegExp.html' title='qt_core::reg_exp::RegExp'>RegExp</a></code></h4>
<div class='docblock'><p>C++ method: <span style='color: green;'><code>QRegExp&amp; QRegExp::operator=(const QRegExp&amp; rx)</code></span></p>

<p><a href="http://doc.qt.io/qt-5/qregexp.html#operator-eq">C++ documentation:</a> <div style='border: 1px solid #5CFF95; background: #D6FFE4; padding: 16px;'><p>Copies the regular expression <i>rx</i> and returns a reference to the copy. The case sensitivity, wildcard, and minimal matching options are also copied.</p></div></p>
</div><h4 id='method.op_eq' class='method'><code>fn <a href='#method.op_eq' class='fnname'>op_eq</a>(&amp;self, rx: &amp;<a class='struct' href='../../qt_core/reg_exp/struct.RegExp.html' title='qt_core::reg_exp::RegExp'>RegExp</a>) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>C++ method: <span style='color: green;'><code>bool QRegExp::operator==(const QRegExp&amp; rx) const</code></span></p>

<p><a href="http://doc.qt.io/qt-5/qregexp.html#operator-eq-eq">C++ documentation:</a> <div style='border: 1px solid #5CFF95; background: #D6FFE4; padding: 16px;'><p>Returns <code>true</code> if this regular expression is equal to <i>rx</i>; otherwise returns <code>false</code>.</p>
<p>Two <a href="http://doc.qt.io/qt-5/qregexp.html">QRegExp</a> objects are equal if they have the same pattern strings and the same settings for case sensitivity, wildcard and minimal matching.</p></div></p>
</div><h4 id='method.op_neq' class='method'><code>fn <a href='#method.op_neq' class='fnname'>op_neq</a>(&amp;self, rx: &amp;<a class='struct' href='../../qt_core/reg_exp/struct.RegExp.html' title='qt_core::reg_exp::RegExp'>RegExp</a>) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>C++ method: <span style='color: green;'><code>bool QRegExp::operator!=(const QRegExp&amp; rx) const</code></span></p>

<p><a href="http://doc.qt.io/qt-5/qregexp.html#operator-not-eq">C++ documentation:</a> <div style='border: 1px solid #5CFF95; background: #D6FFE4; padding: 16px;'><p>Returns <code>true</code> if this regular expression is not equal to <i>rx</i>; otherwise returns <code>false</code>.</p>
<p><b>See also </b><a href="http://doc.qt.io/qt-5/qregexp.html#operator-eq-eq">operator==</a>().</p></div></p>
</div><h4 id='method.pattern' class='method'><code>fn <a href='#method.pattern' class='fnname'>pattern</a>&lt;'largs,&nbsp;Args&gt;(&amp;'largs self, args: Args) -&gt; Args::ReturnType <span class='where'>where Args: <a class='trait' href='../../qt_core/reg_exp/overloading/trait.RegExpPatternArgs.html' title='qt_core::reg_exp::overloading::RegExpPatternArgs'>RegExpPatternArgs</a>&lt;'largs&gt;</span></code></h4>
<div class='docblock'><p>C++ method: <span style='color: green;'><code>QRegExp::pattern</code></span></p>

<p>This is an overloaded function. Available variants:</p>

<p>Rust arguments: <br>1) <code>fn pattern(&amp;self, cpp_utils::AsBox) -&gt; cpp_utils::CppBox&lt;::string::String&gt;</code><br>2) <code>fn pattern(&amp;self, cpp_utils::AsStruct) -&gt; ::string::String</code><br>
C++ method: <span style='color: green;'><code>QString QRegExp::pattern() const</code></span></p>

<p><a href="http://doc.qt.io/qt-5/qregexp.html#pattern">C++ documentation:</a> <div style='border: 1px solid #5CFF95; background: #D6FFE4; padding: 16px;'><p>Returns the pattern string of the regular expression. The pattern has either regular expression syntax or wildcard syntax, depending on <a href="http://doc.qt.io/qt-5/qregexp.html#patternSyntax">patternSyntax</a>().</p>
<p><b>See also </b><a href="http://doc.qt.io/qt-5/qregexp.html#setPattern">setPattern</a>(), <a href="http://doc.qt.io/qt-5/qregexp.html#patternSyntax">patternSyntax</a>(), and <a href="http://doc.qt.io/qt-5/qregexp.html#caseSensitivity">caseSensitivity</a>().</p></div></p>
</div><h4 id='method.pattern_syntax' class='method'><code>fn <a href='#method.pattern_syntax' class='fnname'>pattern_syntax</a>(&amp;self) -&gt; <a class='enum' href='../../qt_core/reg_exp/enum.PatternSyntax.html' title='qt_core::reg_exp::PatternSyntax'>PatternSyntax</a></code></h4>
<div class='docblock'><p>C++ method: <span style='color: green;'><code>QRegExp::PatternSyntax QRegExp::patternSyntax() const</code></span></p>

<p><a href="http://doc.qt.io/qt-5/qregexp.html#patternSyntax">C++ documentation:</a> <div style='border: 1px solid #5CFF95; background: #D6FFE4; padding: 16px;'><p>Returns the syntax used by the regular expression. The default is <a href="http://doc.qt.io/qt-5/qregexp.html#PatternSyntax-enum">QRegExp::RegExp</a>.</p>
<p><b>See also </b><a href="http://doc.qt.io/qt-5/qregexp.html#setPatternSyntax">setPatternSyntax</a>(), <a href="http://doc.qt.io/qt-5/qregexp.html#pattern">pattern</a>(), and <a href="http://doc.qt.io/qt-5/qregexp.html#caseSensitivity">caseSensitivity</a>().</p></div></p>
</div><h4 id='method.pos' class='method'><code>fn <a href='#method.pos' class='fnname'>pos</a>&lt;'largs,&nbsp;Args&gt;(&amp;'largs self, args: Args) -&gt; <a class='type' href='../../libc/type.c_int.html' title='libc::c_int'>c_int</a> <span class='where'>where Args: <a class='trait' href='../../qt_core/reg_exp/overloading/trait.RegExpPosArgs.html' title='qt_core::reg_exp::overloading::RegExpPosArgs'>RegExpPosArgs</a>&lt;'largs&gt;</span></code></h4>
<div class='docblock'><p>C++ method: <span style='color: green;'><code>QRegExp::pos</code></span></p>

<p>This is an overloaded function. Available variants:</p>

<p>Rust arguments: <br>1) <code>fn pos(&amp;self, ()) -&gt; libc::c_int</code><br>2) <code>fn pos(&amp;self, libc::c_int) -&gt; libc::c_int</code><br>
C++ method: <span style='color: green;'><code>int QRegExp::pos(int nth = ?) const</code></span></p>

<p><a href="http://doc.qt.io/qt-5/qregexp.html#pos">C++ documentation:</a> <div style='border: 1px solid #5CFF95; background: #D6FFE4; padding: 16px;'><p>Returns the position of the <i>nth</i> captured text in the searched string. If <i>nth</i> is 0 (the default), pos() returns the position of the whole match.</p>
<p>Example:</p>
<pre class="cpp"><span class="type"><a href="http://doc.qt.io/qt-5/qregexp.html#QRegExp">QRegExp</a></span> rx(<span class="string">&quot;/([a-z]+)/([a-z]+)&quot;</span>);
rx<span class="operator">.</span><a href="http://doc.qt.io/qt-5/qregexp.html#indexIn">indexIn</a>(<span class="string">&quot;Output /dev/null&quot;</span>);   <span class="comment">// returns 7 (position of /dev/null)</span>
rx<span class="operator">.</span>pos(<span class="number">0</span>);                        <span class="comment">// returns 7 (position of /dev/null)</span>
rx<span class="operator">.</span>pos(<span class="number">1</span>);                        <span class="comment">// returns 8 (position of dev)</span>
rx<span class="operator">.</span>pos(<span class="number">2</span>);                        <span class="comment">// returns 12 (position of null)</span></pre>
<p>For zero-length matches, pos() always returns -1. (For example, if cap(4) would return an empty string, pos(4) returns -1.) This is a feature of the implementation.</p>
<p><b>See also </b><a href="http://doc.qt.io/qt-5/qregexp.html#cap">cap</a>() and <a href="http://doc.qt.io/qt-5/qregexp.html#capturedTexts">capturedTexts</a>().</p></div></p>
</div><h4 id='method.pos_mut' class='method'><code>fn <a href='#method.pos_mut' class='fnname'>pos_mut</a>&lt;'largs,&nbsp;Args&gt;(&amp;'largs mut self, args: Args) -&gt; <a class='type' href='../../libc/type.c_int.html' title='libc::c_int'>c_int</a> <span class='where'>where Args: <a class='trait' href='../../qt_core/reg_exp/overloading/trait.RegExpPosMutArgs.html' title='qt_core::reg_exp::overloading::RegExpPosMutArgs'>RegExpPosMutArgs</a>&lt;'largs&gt;</span></code></h4>
<div class='docblock'><p>C++ method: <span style='color: green;'><code>QRegExp::pos</code></span></p>

<p>This is an overloaded function. Available variants:</p>

<p>Rust arguments: <br>1) <code>fn pos_mut(&amp;mut self, ()) -&gt; libc::c_int</code><br>2) <code>fn pos_mut(&amp;mut self, libc::c_int) -&gt; libc::c_int</code><br>
C++ method: <span style='color: green;'><code>int QRegExp::pos(int nth = ?)</code></span></p>

<p><a href="http://doc.qt.io/qt-5/qregexp.html#pos">C++ documentation:</a> <div style='border: 1px solid #5CFF95; background: #D6FFE4; padding: 16px;'><p>Returns the position of the <i>nth</i> captured text in the searched string. If <i>nth</i> is 0 (the default), pos() returns the position of the whole match.</p>
<p>Example:</p>
<pre class="cpp"><span class="type"><a href="http://doc.qt.io/qt-5/qregexp.html#QRegExp">QRegExp</a></span> rx(<span class="string">&quot;/([a-z]+)/([a-z]+)&quot;</span>);
rx<span class="operator">.</span><a href="http://doc.qt.io/qt-5/qregexp.html#indexIn">indexIn</a>(<span class="string">&quot;Output /dev/null&quot;</span>);   <span class="comment">// returns 7 (position of /dev/null)</span>
rx<span class="operator">.</span>pos(<span class="number">0</span>);                        <span class="comment">// returns 7 (position of /dev/null)</span>
rx<span class="operator">.</span>pos(<span class="number">1</span>);                        <span class="comment">// returns 8 (position of dev)</span>
rx<span class="operator">.</span>pos(<span class="number">2</span>);                        <span class="comment">// returns 12 (position of null)</span></pre>
<p>For zero-length matches, pos() always returns -1. (For example, if cap(4) would return an empty string, pos(4) returns -1.) This is a feature of the implementation.</p>
<p><b>See also </b><a href="http://doc.qt.io/qt-5/qregexp.html#cap">cap</a>() and <a href="http://doc.qt.io/qt-5/qregexp.html#capturedTexts">capturedTexts</a>().</p></div></p>
</div><h4 id='method.set_case_sensitivity' class='method'><code>fn <a href='#method.set_case_sensitivity' class='fnname'>set_case_sensitivity</a>(&amp;mut self, cs: <a class='enum' href='../../qt_core/qt/enum.CaseSensitivity.html' title='qt_core::qt::CaseSensitivity'>CaseSensitivity</a>)</code></h4>
<div class='docblock'><p>C++ method: <span style='color: green;'><code>void QRegExp::setCaseSensitivity(Qt::CaseSensitivity cs)</code></span></p>

<p><a href="http://doc.qt.io/qt-5/qregexp.html#setCaseSensitivity">C++ documentation:</a> <div style='border: 1px solid #5CFF95; background: #D6FFE4; padding: 16px;'><p>Sets case sensitive matching to <i>cs</i>.</p>
<p>If <i>cs</i> is <a href="http://doc.qt.io/qt-5/qt.html#CaseSensitivity-enum">Qt::CaseSensitive</a>, <b>.txt$</b> matches <code>readme.txt</code> but not <code>README.TXT</code>.</p>
<p><b>See also </b><a href="http://doc.qt.io/qt-5/qregexp.html#caseSensitivity">caseSensitivity</a>(), <a href="http://doc.qt.io/qt-5/qregexp.html#setPatternSyntax">setPatternSyntax</a>(), <a href="http://doc.qt.io/qt-5/qregexp.html#setPattern">setPattern</a>(), and <a href="http://doc.qt.io/qt-5/qregexp.html#setMinimal">setMinimal</a>().</p></div></p>
</div><h4 id='method.set_minimal' class='method'><code>fn <a href='#method.set_minimal' class='fnname'>set_minimal</a>(&amp;mut self, minimal: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>)</code></h4>
<div class='docblock'><p>C++ method: <span style='color: green;'><code>void QRegExp::setMinimal(bool minimal)</code></span></p>

<p><a href="http://doc.qt.io/qt-5/qregexp.html#setMinimal">C++ documentation:</a> <div style='border: 1px solid #5CFF95; background: #D6FFE4; padding: 16px;'><p>Enables or disables minimal matching. If <i>minimal</i> is false, matching is greedy (maximal) which is the default.</p>
<p>For example, suppose we have the input string &quot;We must be &lt;b&gt;bold&lt;/b&gt;, very &lt;b&gt;bold&lt;/b&gt;!&quot; and the pattern <b>&lt;b&gt;.*&lt;/b&gt;</b>. With the default greedy (maximal) matching, the match is &quot;We must be <u>&lt;b&gt;bold&lt;/b&gt;, very &lt;b&gt;bold&lt;/b&gt;</u>!&quot;. But with minimal (non-greedy) matching, the first match is: &quot;We must be <u>&lt;b&gt;bold&lt;/b&gt;</u>, very &lt;b&gt;bold&lt;/b&gt;!&quot; and the second match is &quot;We must be &lt;b&gt;bold&lt;/b&gt;, very <u>&lt;b&gt;bold&lt;/b&gt;</u>!&quot;. In practice we might use the pattern <b>&lt;b&gt;[<sup>&lt;]*&lt;/b&gt;</b></sup> instead, although this will still fail for nested tags.</p>
<p><b>See also </b><a href="http://doc.qt.io/qt-5/qregexp.html#isMinimal">isMinimal</a>() and <a href="http://doc.qt.io/qt-5/qregexp.html#setCaseSensitivity">setCaseSensitivity</a>().</p></div></p>
</div><h4 id='method.set_pattern' class='method'><code>fn <a href='#method.set_pattern' class='fnname'>set_pattern</a>(&amp;mut self, pattern: &amp;<a class='struct' href='../../qt_core/string/struct.String.html' title='qt_core::string::String'>String</a>)</code></h4>
<div class='docblock'><p>C++ method: <span style='color: green;'><code>void QRegExp::setPattern(const QString&amp; pattern)</code></span></p>

<p><a href="http://doc.qt.io/qt-5/qregexp.html#setPattern">C++ documentation:</a> <div style='border: 1px solid #5CFF95; background: #D6FFE4; padding: 16px;'><p>Sets the pattern string to <i>pattern</i>. The case sensitivity, wildcard, and minimal matching options are not changed.</p>
<p><b>See also </b><a href="http://doc.qt.io/qt-5/qregexp.html#pattern">pattern</a>(), <a href="http://doc.qt.io/qt-5/qregexp.html#setPatternSyntax">setPatternSyntax</a>(), and <a href="http://doc.qt.io/qt-5/qregexp.html#setCaseSensitivity">setCaseSensitivity</a>().</p></div></p>
</div><h4 id='method.set_pattern_syntax' class='method'><code>fn <a href='#method.set_pattern_syntax' class='fnname'>set_pattern_syntax</a>(&amp;mut self, syntax: <a class='enum' href='../../qt_core/reg_exp/enum.PatternSyntax.html' title='qt_core::reg_exp::PatternSyntax'>PatternSyntax</a>)</code></h4>
<div class='docblock'><p>C++ method: <span style='color: green;'><code>void QRegExp::setPatternSyntax(QRegExp::PatternSyntax syntax)</code></span></p>

<p><a href="http://doc.qt.io/qt-5/qregexp.html#setPatternSyntax">C++ documentation:</a> <div style='border: 1px solid #5CFF95; background: #D6FFE4; padding: 16px;'><p>Sets the syntax mode for the regular expression. The default is <a href="http://doc.qt.io/qt-5/qregexp.html#PatternSyntax-enum">QRegExp::RegExp</a>.</p>
<p>Setting <i>syntax</i> to <a href="http://doc.qt.io/qt-5/qregexp.html#PatternSyntax-enum">QRegExp::Wildcard</a> enables simple shell-like <a href="http://doc.qt.io/qt-5/qregexp.html#qregexp-wildcard-matching">QRegExp wildcard matching</a>. For example, <b>r*.txt</b> matches the string <code>readme.txt</code> in wildcard mode, but does not match <code>readme</code>.</p>
<p>Setting <i>syntax</i> to <a href="http://doc.qt.io/qt-5/qregexp.html#PatternSyntax-enum">QRegExp::FixedString</a> means that the pattern is interpreted as a plain string. Special characters (e.g., backslash) don&#39;t need to be escaped then.</p>
<p><b>See also </b><a href="http://doc.qt.io/qt-5/qregexp.html#patternSyntax">patternSyntax</a>(), <a href="http://doc.qt.io/qt-5/qregexp.html#setPattern">setPattern</a>(), <a href="http://doc.qt.io/qt-5/qregexp.html#setCaseSensitivity">setCaseSensitivity</a>(), and <a href="http://doc.qt.io/qt-5/qregexp.html#escape">escape</a>().</p></div></p>
</div><h4 id='method.swap' class='method'><code>fn <a href='#method.swap' class='fnname'>swap</a>(&amp;mut self, other: &amp;mut <a class='struct' href='../../qt_core/reg_exp/struct.RegExp.html' title='qt_core::reg_exp::RegExp'>RegExp</a>)</code></h4>
<div class='docblock'><p>C++ method: <span style='color: green;'><code>void QRegExp::swap(QRegExp&amp; other)</code></span></p>

<p><a href="http://doc.qt.io/qt-5/qregexp.html#swap">C++ documentation:</a> <div style='border: 1px solid #5CFF95; background: #D6FFE4; padding: 16px;'><p>Swaps regular expression <i>other</i> with this regular expression. This operation is very fast and never fails.</p>
<p>This function was introduced in  Qt 4.8.</p></div></p>
</div></div><h2 id='implementations'>Trait Implementations</h2><h3 class='impl'><span class='in-band'><code>impl <a class='trait' href='../../cpp_utils/new_uninitialized/trait.NewUninitialized.html' title='cpp_utils::new_uninitialized::NewUninitialized'>NewUninitialized</a> for <a class='struct' href='../../qt_core/reg_exp/struct.RegExp.html' title='qt_core::reg_exp::RegExp'>RegExp</a></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-126599' class='srclink' href='../../src/qt_core/home/ri/rust/rust_qt/cache/qt_core/src/reg_exp.rs.html#58-62' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.new_uninitialized' class='method'><code>unsafe fn <a href='../../cpp_utils/new_uninitialized/trait.NewUninitialized.html#tymethod.new_uninitialized' class='fnname'>new_uninitialized</a>() -&gt; <a class='struct' href='../../qt_core/reg_exp/struct.RegExp.html' title='qt_core::reg_exp::RegExp'>RegExp</a></code></h4>
<div class='docblock'><p>Creates new object with uninitialized internal buffer. <a href="../../cpp_utils/new_uninitialized/trait.NewUninitialized.html#tymethod.new_uninitialized">Read more</a></p>
</div></div><h3 class='impl'><span class='in-band'><code>impl <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.Drop.html' title='core::ops::Drop'>Drop</a> for <a class='struct' href='../../qt_core/reg_exp/struct.RegExp.html' title='qt_core::reg_exp::RegExp'>RegExp</a></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-126707' class='srclink' href='../../src/qt_core/home/ri/rust/rust_qt/cache/qt_core/src/reg_exp.rs.html#516-523' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.drop' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/core/ops/trait.Drop.html#tymethod.drop' class='fnname'>drop</a>(&amp;mut self)</code></h4>
<div class='docblock'><p>C++ method: <span style='color: green;'><code>[destructor] void QRegExp::~QRegExp()</code></span></p>

<p><a href="http://doc.qt.io/qt-5/qregexp.html#dtor.QRegExp">C++ documentation:</a> <div style='border: 1px solid #5CFF95; background: #D6FFE4; padding: 16px;'><p>Destroys the regular expression and cleans up its internal data.</p></div></p>
</div></div><h3 class='impl'><span class='in-band'><code>impl <a class='trait' href='../../cpp_utils/trait.CppDeletable.html' title='cpp_utils::CppDeletable'>CppDeletable</a> for <a class='struct' href='../../qt_core/reg_exp/struct.RegExp.html' title='qt_core::reg_exp::RegExp'>RegExp</a></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-126710' class='srclink' href='../../src/qt_core/home/ri/rust/rust_qt/cache/qt_core/src/reg_exp.rs.html#525-529' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.deleter' class='method'><code>fn <a href='../../cpp_utils/trait.CppDeletable.html#tymethod.deleter' class='fnname'>deleter</a>() -&gt; <a class='type' href='../../cpp_utils/type.Deleter.html' title='cpp_utils::Deleter'>Deleter</a>&lt;Self&gt;</code></h4>
<div class='docblock'><p>Returns deleter function for this type.</p>
</div></div><h3 class='impl'><span class='in-band'><code>impl&lt;'largs&gt; <a class='trait' href='../../qt_core/sort_filter_proxy_model/overloading/trait.SortFilterProxyModelSetFilterRegExpArgs.html' title='qt_core::sort_filter_proxy_model::overloading::SortFilterProxyModelSetFilterRegExpArgs'>SortFilterProxyModelSetFilterRegExpArgs</a>&lt;'largs&gt; for &amp;'largs <a class='struct' href='../../qt_core/reg_exp/struct.RegExp.html' title='qt_core::reg_exp::RegExp'>RegExp</a></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-136960' class='srclink' href='../../src/qt_core/home/ri/rust/rust_qt/cache/qt_core/src/sort_filter_proxy_model.rs.html#3144-3149' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.exec' class='method'><code>fn <a href='../../qt_core/sort_filter_proxy_model/overloading/trait.SortFilterProxyModelSetFilterRegExpArgs.html#tymethod.exec' class='fnname'>exec</a>(self, original_self: &amp;'largs mut <a class='struct' href='../../qt_core/sort_filter_proxy_model/struct.SortFilterProxyModel.html' title='qt_core::sort_filter_proxy_model::SortFilterProxyModel'>SortFilterProxyModel</a>)</code></h4>
</div><h3 class='impl'><span class='in-band'><code>impl&lt;'largs&gt; <a class='trait' href='../../qt_core/string/overloading/trait.StringContainsArgs.html' title='qt_core::string::overloading::StringContainsArgs'>StringContainsArgs</a>&lt;'largs&gt; for &amp;'largs mut <a class='struct' href='../../qt_core/reg_exp/struct.RegExp.html' title='qt_core::reg_exp::RegExp'>RegExp</a></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-141475' class='srclink' href='../../src/qt_core/home/ri/rust/rust_qt/cache/qt_core/src/string.rs.html#6432-6440' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.exec-1' class='method'><code>fn <a href='../../qt_core/string/overloading/trait.StringContainsArgs.html#tymethod.exec' class='fnname'>exec</a>(self, original_self: &amp;'largs <a class='struct' href='../../qt_core/string/struct.String.html' title='qt_core::string::String'>String</a>) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
</div><h3 class='impl'><span class='in-band'><code>impl&lt;'largs&gt; <a class='trait' href='../../qt_core/string/overloading/trait.StringContainsArgs.html' title='qt_core::string::overloading::StringContainsArgs'>StringContainsArgs</a>&lt;'largs&gt; for &amp;'largs <a class='struct' href='../../qt_core/reg_exp/struct.RegExp.html' title='qt_core::reg_exp::RegExp'>RegExp</a></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-141481' class='srclink' href='../../src/qt_core/home/ri/rust/rust_qt/cache/qt_core/src/string.rs.html#6441-6449' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.exec-2' class='method'><code>fn <a href='../../qt_core/string/overloading/trait.StringContainsArgs.html#tymethod.exec' class='fnname'>exec</a>(self, original_self: &amp;'largs <a class='struct' href='../../qt_core/string/struct.String.html' title='qt_core::string::String'>String</a>) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
</div><h3 class='impl'><span class='in-band'><code>impl&lt;'largs&gt; <a class='trait' href='../../qt_core/string/overloading/trait.StringCountArgs.html' title='qt_core::string::overloading::StringCountArgs'>StringCountArgs</a>&lt;'largs&gt; for &amp;'largs <a class='struct' href='../../qt_core/reg_exp/struct.RegExp.html' title='qt_core::reg_exp::RegExp'>RegExp</a></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-141544' class='srclink' href='../../src/qt_core/home/ri/rust/rust_qt/cache/qt_core/src/string.rs.html#6522-6530' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.exec-3' class='method'><code>fn <a href='../../qt_core/string/overloading/trait.StringCountArgs.html#tymethod.exec' class='fnname'>exec</a>(self, original_self: &amp;'largs <a class='struct' href='../../qt_core/string/struct.String.html' title='qt_core::string::String'>String</a>) -&gt; <a class='type' href='../../libc/type.c_int.html' title='libc::c_int'>c_int</a></code></h4>
</div><h3 class='impl'><span class='in-band'><code>impl&lt;'largs&gt; <a class='trait' href='../../qt_core/string/overloading/trait.StringIndexOfArgs.html' title='qt_core::string::overloading::StringIndexOfArgs'>StringIndexOfArgs</a>&lt;'largs&gt; for &amp;'largs mut <a class='struct' href='../../qt_core/reg_exp/struct.RegExp.html' title='qt_core::reg_exp::RegExp'>RegExp</a></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-141951' class='srclink' href='../../src/qt_core/home/ri/rust/rust_qt/cache/qt_core/src/string.rs.html#7142-7150' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.exec-4' class='method'><code>fn <a href='../../qt_core/string/overloading/trait.StringIndexOfArgs.html#tymethod.exec' class='fnname'>exec</a>(self, original_self: &amp;'largs <a class='struct' href='../../qt_core/string/struct.String.html' title='qt_core::string::String'>String</a>) -&gt; <a class='type' href='../../libc/type.c_int.html' title='libc::c_int'>c_int</a></code></h4>
</div><h3 class='impl'><span class='in-band'><code>impl&lt;'largs&gt; <a class='trait' href='../../qt_core/string/overloading/trait.StringIndexOfArgs.html' title='qt_core::string::overloading::StringIndexOfArgs'>StringIndexOfArgs</a>&lt;'largs&gt; for &amp;'largs <a class='struct' href='../../qt_core/reg_exp/struct.RegExp.html' title='qt_core::reg_exp::RegExp'>RegExp</a></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-141964' class='srclink' href='../../src/qt_core/home/ri/rust/rust_qt/cache/qt_core/src/string.rs.html#7162-7170' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.exec-5' class='method'><code>fn <a href='../../qt_core/string/overloading/trait.StringIndexOfArgs.html#tymethod.exec' class='fnname'>exec</a>(self, original_self: &amp;'largs <a class='struct' href='../../qt_core/string/struct.String.html' title='qt_core::string::String'>String</a>) -&gt; <a class='type' href='../../libc/type.c_int.html' title='libc::c_int'>c_int</a></code></h4>
</div><h3 class='impl'><span class='in-band'><code>impl&lt;'largs&gt; <a class='trait' href='../../qt_core/string/overloading/trait.StringLastIndexOfArgs.html' title='qt_core::string::overloading::StringLastIndexOfArgs'>StringLastIndexOfArgs</a>&lt;'largs&gt; for &amp;'largs mut <a class='struct' href='../../qt_core/reg_exp/struct.RegExp.html' title='qt_core::reg_exp::RegExp'>RegExp</a></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-142125' class='srclink' href='../../src/qt_core/home/ri/rust/rust_qt/cache/qt_core/src/string.rs.html#7378-7386' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.exec-6' class='method'><code>fn <a href='../../qt_core/string/overloading/trait.StringLastIndexOfArgs.html#tymethod.exec' class='fnname'>exec</a>(self, original_self: &amp;'largs <a class='struct' href='../../qt_core/string/struct.String.html' title='qt_core::string::String'>String</a>) -&gt; <a class='type' href='../../libc/type.c_int.html' title='libc::c_int'>c_int</a></code></h4>
</div><h3 class='impl'><span class='in-band'><code>impl&lt;'largs&gt; <a class='trait' href='../../qt_core/string/overloading/trait.StringLastIndexOfArgs.html' title='qt_core::string::overloading::StringLastIndexOfArgs'>StringLastIndexOfArgs</a>&lt;'largs&gt; for &amp;'largs <a class='struct' href='../../qt_core/reg_exp/struct.RegExp.html' title='qt_core::reg_exp::RegExp'>RegExp</a></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-142138' class='srclink' href='../../src/qt_core/home/ri/rust/rust_qt/cache/qt_core/src/string.rs.html#7398-7406' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.exec-7' class='method'><code>fn <a href='../../qt_core/string/overloading/trait.StringLastIndexOfArgs.html#tymethod.exec' class='fnname'>exec</a>(self, original_self: &amp;'largs <a class='struct' href='../../qt_core/string/struct.String.html' title='qt_core::string::String'>String</a>) -&gt; <a class='type' href='../../libc/type.c_int.html' title='libc::c_int'>c_int</a></code></h4>
</div><h3 class='impl'><span class='in-band'><code>impl&lt;'largs&gt; <a class='trait' href='../../qt_core/string/overloading/trait.StringRemoveArgs.html' title='qt_core::string::overloading::StringRemoveArgs'>StringRemoveArgs</a>&lt;'largs&gt; for &amp;'largs <a class='struct' href='../../qt_core/reg_exp/struct.RegExp.html' title='qt_core::reg_exp::RegExp'>RegExp</a></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-143224' class='srclink' href='../../src/qt_core/home/ri/rust/rust_qt/cache/qt_core/src/string.rs.html#8942-8951' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.exec-8' class='method'><code>fn <a href='../../qt_core/string/overloading/trait.StringRemoveArgs.html#tymethod.exec' class='fnname'>exec</a>(self, original_self: &amp;'largs mut <a class='struct' href='../../qt_core/string/struct.String.html' title='qt_core::string::String'>String</a>) -&gt; &amp;'largs mut <a class='struct' href='../../qt_core/string/struct.String.html' title='qt_core::string::String'>String</a></code></h4>
</div><h3 class='impl'><span class='in-band'><code>impl&lt;'largs&gt; <a class='trait' href='../../qt_core/string_list/overloading/trait.StringListIndexOfArgs.html' title='qt_core::string_list::overloading::StringListIndexOfArgs'>StringListIndexOfArgs</a>&lt;'largs&gt; for &amp;'largs mut <a class='struct' href='../../qt_core/reg_exp/struct.RegExp.html' title='qt_core::reg_exp::RegExp'>RegExp</a></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-145212' class='srclink' href='../../src/qt_core/home/ri/rust/rust_qt/cache/qt_core/src/string_list.rs.html#978-986' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.exec-9' class='method'><code>fn <a href='../../qt_core/string_list/overloading/trait.StringListIndexOfArgs.html#tymethod.exec' class='fnname'>exec</a>(self, original_self: &amp;'largs <a class='struct' href='../../qt_core/string_list/struct.StringList.html' title='qt_core::string_list::StringList'>StringList</a>) -&gt; <a class='type' href='../../libc/type.c_int.html' title='libc::c_int'>c_int</a></code></h4>
</div><h3 class='impl'><span class='in-band'><code>impl&lt;'largs&gt; <a class='trait' href='../../qt_core/string_list/overloading/trait.StringListIndexOfArgs.html' title='qt_core::string_list::overloading::StringListIndexOfArgs'>StringListIndexOfArgs</a>&lt;'largs&gt; for &amp;'largs <a class='struct' href='../../qt_core/reg_exp/struct.RegExp.html' title='qt_core::reg_exp::RegExp'>RegExp</a></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-145225' class='srclink' href='../../src/qt_core/home/ri/rust/rust_qt/cache/qt_core/src/string_list.rs.html#998-1006' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.exec-10' class='method'><code>fn <a href='../../qt_core/string_list/overloading/trait.StringListIndexOfArgs.html#tymethod.exec' class='fnname'>exec</a>(self, original_self: &amp;'largs <a class='struct' href='../../qt_core/string_list/struct.StringList.html' title='qt_core::string_list::StringList'>StringList</a>) -&gt; <a class='type' href='../../libc/type.c_int.html' title='libc::c_int'>c_int</a></code></h4>
</div><h3 class='impl'><span class='in-band'><code>impl&lt;'largs&gt; <a class='trait' href='../../qt_core/string_list/overloading/trait.StringListLastIndexOfArgs.html' title='qt_core::string_list::overloading::StringListLastIndexOfArgs'>StringListLastIndexOfArgs</a>&lt;'largs&gt; for &amp;'largs mut <a class='struct' href='../../qt_core/reg_exp/struct.RegExp.html' title='qt_core::reg_exp::RegExp'>RegExp</a></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-145269' class='srclink' href='../../src/qt_core/home/ri/rust/rust_qt/cache/qt_core/src/string_list.rs.html#1055-1063' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.exec-11' class='method'><code>fn <a href='../../qt_core/string_list/overloading/trait.StringListLastIndexOfArgs.html#tymethod.exec' class='fnname'>exec</a>(self, original_self: &amp;'largs <a class='struct' href='../../qt_core/string_list/struct.StringList.html' title='qt_core::string_list::StringList'>StringList</a>) -&gt; <a class='type' href='../../libc/type.c_int.html' title='libc::c_int'>c_int</a></code></h4>
</div><h3 class='impl'><span class='in-band'><code>impl&lt;'largs&gt; <a class='trait' href='../../qt_core/string_list/overloading/trait.StringListLastIndexOfArgs.html' title='qt_core::string_list::overloading::StringListLastIndexOfArgs'>StringListLastIndexOfArgs</a>&lt;'largs&gt; for &amp;'largs <a class='struct' href='../../qt_core/reg_exp/struct.RegExp.html' title='qt_core::reg_exp::RegExp'>RegExp</a></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-145282' class='srclink' href='../../src/qt_core/home/ri/rust/rust_qt/cache/qt_core/src/string_list.rs.html#1075-1083' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.exec-12' class='method'><code>fn <a href='../../qt_core/string_list/overloading/trait.StringListLastIndexOfArgs.html#tymethod.exec' class='fnname'>exec</a>(self, original_self: &amp;'largs <a class='struct' href='../../qt_core/string_list/struct.StringList.html' title='qt_core::string_list::StringList'>StringList</a>) -&gt; <a class='type' href='../../libc/type.c_int.html' title='libc::c_int'>c_int</a></code></h4>
</div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../../";
        window.currentCrate = "qt_core";
        window.playgroundUrl = "";
    </script>
    <script src="../../jquery.js"></script>
    <script src="../../main.js"></script>
    
    <script defer src="../../search-index.js"></script>
</body>
</html>